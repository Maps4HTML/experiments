<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoName Search</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-/bQdsTh/da6pkI1MST/rWKFNjaCP5gBSY4sEBT38Q/9RBh9AH40zEOg7Hlq2THRZ" crossorigin="anonymous"></script>

    <script type="module" src="../../dist/mapml-viewer.js"></script>
    <style>
        html, body {
        height: 100%; /* These styles are required if you wish to use a % based
                         height value on the mapml-viewer element. */
        }
        mapml-viewer:defined {
            width: 75%;
            height: 90%;
        }
        h2 {
            width: 100%;
            text-align: center;
        }
        .result {
            width: 100%;
            background-color: #78bbc0;
            color: white;
            padding: 0.5em 1em;
            text-decoration: none;
        }
        .result:hover {
            background-color: #555;
        }

        .result:active {
            background-color: black;
        }

        .result:visited {
            background-color: #ccc;
        }
        .results_container {
            overflow: auto;
            overflow: auto;
            display:none;
            max-height:80%;
        }
        .result_description {
            font-size: 11px;
        }
        .search {
            float:left;
            width: 20%;
            max-width: 20%;
            margin: auto;
            height:100%;
        }
        .search_input {
            width:70%;
        }
        .search_button {
            width:20%;
        }
      </style>
</head>
<body>
    
    <div class="search" role="search">
        <h2>GeoName Search</h2>

        <input type="search" class="search_input" id="query" placeholder="Locations in Canada" autocomplete="off" name="query" size="20%"/>
        <button onclick="update()" class="search_button btn btn-primary btn-sm" id="searchBtn">Search</button>
        
        <br>
        <output id="results_count" for="query"></output>
        <div id="results" class="results_container"></div>
    </div>

    <mapml-viewer projection="OSMTILE" zoom="4" lat="58.276703" lon="-103.710938" controls controlslist="nofullscreen" id="map">
        <layer- label="OpenStreetMap" src="https://geogratis.gc.ca/mapml/en/osmtile/osm/" checked></layer->
    </mapml-viewer>

    <!-- ############################################### TEMPLATES ############################################### -->
    <!-- Template layer to add to the mapml-viewer -->
    <template id = "new_layer">
        <layer- label="Test" checked="" id="layer">
            <map-meta name="projection" content="OSMTILE"></map-meta>
            <map-feature class="child" zoom="2">
                <map-featurecaption id="caption">Bounding Box Extent</map-featurecaption>
                <map-geometry id="geom">
                </map-geometry>
                <map-properties id="properties"></map-properties>
            </map-feature>
        </layer->
    </template>

    <!-- Template to add geometrycollection layers and its component -->
    <template id="geometrycollection_temp">
        <map-geometrycollection id="geometrycollection"></map-geometrycollection>
    </template>

    <!-- Templates to add features to geometry -->
    <template id ="linestring">
        <map-linestring>
            <map-coordinates id="coords"></map-coordinates>
        </map-linestring>
    </template>

    <template id="polygon">
        <map-polygon id="poly">
        </map-polygon>
    </template>

    <template id="point_temp">
        <map-point id="point">
        </map-point>
    </template>

    <!-- Template to add coordinates to features -->
    <template id="coords_temp">
        <map-coordinates id="coords"></map-coordinates>
    </template>
    <!-- ############################################### TEMPLATES ############################################### -->
    
    <script>
        // Handling pressing Enter on focused search results divs
        function handleEnter(e) {
            let keycode = (e.keyCode ? e.keyCode : e.which);
            if (keycode === Number.parseInt("13")) {
                document.activeElement.click();
            }
        }

        // Handling enter on the input search box, the search button is clicked
        let input = document.getElementById("query");
        input.addEventListener("keyup", function(event) {
            if (event.keyCode === 13) {
                event.preventDefault();
                document.getElementById("searchBtn").click();
            }
        });

        // Select the mapml-viewer
        let mapp = document.querySelector("#map");

        // Will store the json search results
        let search_results = ""; 

        // Computes the zoom extent based on bounding box's decimal degrees
        // getZoomExtent: listof(Num, Num, Num, Num) -> Int(3-16)
        function getZoomExtent (bbox) {
            let x = [bbox[0], bbox[2]];
            let y = [bbox[1], bbox[3]];
            let difference = Math.max(Math.abs(x[0]-x[1]), Math.abs(y[0]-y[1])).toPrecision(2);

            // choosing zoom level, based on the decimal degree extent
            if (difference >=30) {
                return 3;
            } else if (difference >=25) {
                return 4;
            } else if (difference >= 10) {
                return 5;
            } else if (difference >= 5) {
                return 6;
            } else if (difference >= 3) {
                return 7;
            } else if (difference >= 2) {
                return 8;
            } else if (difference >= 1) {
                return 9;
            } else if (difference >= 0.7) {
                return 10;
            } else if (difference >= 0.5) {
                return 11;
            } else if (difference >= 0.2) {
                return 12;
            } else if (difference >= 0.1) {
                return 13;
            } else if (difference == 0.04) { // Point feature
                return 10;
            } else if (difference >= 0.05) {
                return 14;
            } else if (difference >= 0.02){
                return 15;
            } else {
                return 16;
            }
        }

        // Takes GeoJSON Properties to return a HTML table
        // properties2Table: Str -> HTML Table
        function properties2Table(json) {
            let _table_ = document.createElement('table');

            // Creating a Table Header
            let thead = _table_.createTHead();
            let row = thead.insertRow();
            let th1 = document.createElement("th");
            let th2 = document.createElement("th");
            th1.appendChild(document.createTextNode("Property name"));
            th2.appendChild(document.createTextNode("Property value"));
            th1.setAttribute("role", "columnheader");
            th2.setAttribute("role", "columnheader");
            th1.setAttribute("scope", "col");
            th2.setAttribute("scope", "col");
            row.appendChild(th1);
            row.appendChild(th2);
            
            // Creating table body and populating it from the JSON
            let tbody = _table_.createTBody();
            for (let key in json) {
                if (json.hasOwnProperty(key)) {

                    let row = tbody.insertRow();
                    let th = document.createElement("th");
                    let td = document.createElement("td");
                    th.appendChild(document.createTextNode(key));
                    td.appendChild(document.createTextNode(json[key]));
                    th.setAttribute("scope", "row");
                    td.setAttribute("itemprop", key);
                    row.appendChild(th);
                    row.appendChild(td);
                }
            }

            return _table_;
        }

        // Sorts GEOJSON to to be used by MapMl
        // geoJson2MapMl: Str -> list(listof(list), Int(0-3), HTML Table)
        async function geoJson2MapMl(url) {
            let response = await fetch(url);
            let data = await response.json();

            let arrs = data.geometry;

            let table = properties2Table(data.properties);

            // Checking the type of feature
            if (data.geometry.type === "MultiPolygon") {
                return [arrs.coordinates, 1, table];
            } else if (data.geometry.type === "MultiPoint") {
                return [arrs.coordinates, 0, table];
            } else if (data.geometry.type === "GeometryCollection") {
                return [arrs.geometries, 2, table];
            } else if (data.geometry.type === "MultiLineString") {
                return [arrs.coordinates, 3, table];
            } else {
                return [arrs, data.geometry.type, table];
            }
            
        }

        // Draws a new layer and moves the map to the layer
        // mapPane: Int -> None
        // Effects: Changes map's zoom and location. Also creates and adds a new layer to the map
        async function mapPane(id) {
            let feature_geojson = search_results[id].feature.links.self.href + ".geojson";
            console.log(feature_geojson);

            // zooming to location
            let zoom = getZoomExtent(search_results[id].bbox);
            mapp.zoomTo(search_results[id].latitude, search_results[id].longitude, zoom);

            // Creating a new layer based on the template
            let template = document.querySelector('#new_layer');
            let clone = template.content.cloneNode(true);
            
            // Setting Layer Name
            let layer = clone.getElementById("layer"); 
            layer.setAttribute("label", search_results[id].name);

            // Setting feature caption
            let map_featurecaption = clone.getElementById("caption");
            map_featurecaption.innerHTML = search_results[id].name;

            // Accessing the geom element to append features to
            let geom = clone.getElementById("geom");

            // Getting information about the feature being added
            feature = await geoJson2MapMl(feature_geojson);

            // Adding the properties 
            let properties = clone.getElementById("properties");
            properties.appendChild(feature[2]);

            if (feature[1] === 1) { // ################ If it is a MultiPolygon ################

                // Create polygon
                let polygon_template = document.querySelector('#polygon');     
                let clone_polygon = polygon_template.content.cloneNode(true);
                clone_polygon = clone_polygon.getElementById("poly");

                for (i=0;i<feature[0][0].length;i++) {
                    // Create map-coords to add to the polygon
                    let coords_template = document.querySelector('#coords_temp');
                    let clone_coords = coords_template.content.cloneNode(true);
                    clone_coords = clone_coords.getElementById("coords");

                    let c = feature[0][0][i];
                    let out = ""
                    for (y = 0; y < c.length; y++) {
                        out = out + c[y][0] + " " + c[y][1] + " ";
                    }
                    clone_coords.innerHTML = out;
                    clone_polygon.appendChild(clone_coords);
                }
                geom.appendChild(clone_polygon);
                
            } else if (feature[1] === 0) { // ################ If it is MultiPoint ################
                let out = feature[0][0][0] + " " + feature[0][0][1];
                
                // Create Point element
                let point_template = document.querySelector('#point_temp');     
                let clone_point = point_template.content.cloneNode(true);
                clone_point = clone_point.getElementById("point");

                // Create map-coords to add to the point
                let coords_template = document.querySelector('#coords_temp');
                let clone_coords = coords_template.content.cloneNode(true);
                clone_coords = clone_coords.getElementById("coords");

                clone_coords.innerHTML = out;

                clone_point.appendChild(clone_coords);
                geom.appendChild(clone_point);
            } else if (feature[1] === 2) { //  ################ If it is GeometryCollection ################ 

                let geometrycollection_template = document.querySelector('#geometrycollection_temp');
                let clone_geometrycollection = geometrycollection_template.content.cloneNode(true);
                clone_geometrycollection = clone_geometrycollection.getElementById("geometrycollection");

                // Going over each feature in the geometrycollection
                for (i=0;i<feature[0].length;i++) {
                    if (feature[0][i].type === "LineString") {
                        let linestring_template = document.querySelector('#linestring');
                        let clone_linestring = linestring_template.content.cloneNode(true);
                        let linestring_coordindates = clone_linestring.getElementById("coords");
                        
                        let out = "";

                        for (x=0;x<feature[0][i].coordinates.length;x++) {
                            out = out + feature[0][i].coordinates[x][0] + " " + feature[0][i].coordinates[x][1] + " ";
                        }

                        linestring_coordindates.innerHTML = out;
                        clone_geometrycollection.appendChild(clone_linestring);
                        
                    } else if (feature[0][i].type === "Polygon") {
                        let polygon_template = document.querySelector('#polygon');
                        
                        let clone_polygon = polygon_template.content.cloneNode(true);
                        clone_polygon = clone_polygon.getElementById("poly");
                        
                        // Going over each coordinates
                        for (y=0;y<feature[0][i].coordinates.length;y++) {
                            
                            let out = "";
                            let coords_template = document.querySelector('#coords_temp');
                            let clone_coords = coords_template.content.cloneNode(true);
                            clone_coords = clone_coords.getElementById("coords");

                            // Going over coordinates for the polygon
                            for (x=0;x<feature[0][i].coordinates[y].length;x++) {
                                out = out + feature[0][i].coordinates[y][x][0] + " " + feature[0][i].coordinates[y][x][1] + " ";
                            }

                            // Create map-coordinates element and append it to clone_polygon
                            clone_coords.innerHTML = out; // append to innerhtml of coords

                            clone_polygon.appendChild(clone_coords);
                            
                        }
                        clone_geometrycollection.appendChild(clone_polygon);
                    } else {
                        alert("Geometrycollection not fully drawn!");
                    }
                }

                geom.appendChild(clone_geometrycollection);
                
            } else if (feature[1] === 3) { // ################ If it is MultiLineString ################

                // Going over each line
                for (i=0;i<feature[0].length;i++) {
                    let line_template = document.querySelector('#linestring');
                    let clone_line = line_template.content.cloneNode(true);
                    let out = "";
                    let line_coordindates = clone_line.getElementById("coords");
                
                    // Going over coordinates in each seperate line
                    for (y=0;y<feature[0][i].length;y++) {
                        out = out + feature[0][i][y][0] + " " + feature[0][i][y][1] + " "; 
                    }

                    line_coordindates.innerHTML = out
                    
                    geom.appendChild(clone_line);
                }

            } else { // ################ If feature is of any other type ################
                console.log("Unsupported Type: " + feature[1]);
                alert("Unsupported Type: " + feature[1]);
            }

            // removing the previous layer which was displayed on search, if any
            if (mapp.querySelector('#layer') != null) {
                mapp.removeChild(mapp.querySelector("#layer"));
            }

            // Add the newly created layer to mapmlviewer
            mapp.appendChild(clone);
            //document.querySelector("#layer").focus();
            //console.log(document.querySelector('mapml-viewer').shadowRoot.querySelector("g").firstElementChild);
            
            // Focusing on the map after a new layer is added
            document.getElementById('map').tabIndex = -1;
            document.getElementById('map').focus();
            
        }

        // Display Search Results based on the search key term
        // displayResults: JSON -> None
        // Effects: Populates the results container with search results
        function displayResults(obj) {
            // Enable display panel
            document.getElementById("results").style.display = "block";
            for (let i=0; i < obj.length; i++) {
                document.querySelector("#results").innerHTML = document.querySelector("#results").innerHTML + "<div class='result' role='button' tabindex='0' onkeypress='handleEnter(event)' onclick='mapPane(" + i + ")'>" + obj[i].name + "<div class='result_description'>" + obj[i].concise.code + " (" + obj[i].decision + ")</div></div>"
            }
        }

        // update Search Results based on the search Item, initiated when the "Search" button is pressed
        // update: None -> None
        // Effects: Makes an API Call to update global variable (search_results) with JSON results, and updates the count of results found
        function update() {
            // Reset the results
            document.querySelector("#results").innerHTML = ""

            let search_phrase = document.getElementById("query").value;

            fetch('http://geogratis.gc.ca/services/geoname/en/geonames.json?q=' + search_phrase)
                .then(response => response.json())
                .then(json => {
                    document.querySelector("#results_count").innerHTML = json.items.length + " results found." + "<br>";

                    displayResults(json.items);
                    search_results = json.items;
                })
        }

    </script>
</body>
</html>