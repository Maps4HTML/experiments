{"version":3,"file":"layer.js","sources":["../src/layer.js"],"sourcesContent":["import './leaflet.js'; // a lightly modified version of Leaflet for use as browser module\nimport './mapml.js'; // modified URI to make the function a property of window scope (possibly a bad thing to do).\n\nexport class MapLayer extends HTMLElement {\n  static get observedAttributes() {\n    return ['src', 'label', 'checked', 'hidden', 'opacity'];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get src() {\n    return this.hasAttribute('src') ? this.getAttribute('src') : '';\n  }\n\n  set src(val) {\n    if (val) {\n      this.setAttribute('src', val);\n    }\n  }\n  get label() {\n    if (this._layer) return this._layer.getName();\n    else return this.hasAttribute('label') ? this.getAttribute('label') : '';\n  }\n  set label(val) {\n    if (val) {\n      this.setAttribute('label', val);\n    }\n  }\n  get checked() {\n    return this.hasAttribute('checked');\n  }\n\n  set checked(val) {\n    if (val) {\n      this.setAttribute('checked', '');\n    } else {\n      this.removeAttribute('checked');\n    }\n  }\n\n  get hidden() {\n    return this.hasAttribute('hidden');\n  }\n\n  set hidden(val) {\n    if (val) {\n      this.setAttribute('hidden', '');\n    } else {\n      this.removeAttribute('hidden');\n    }\n  }\n\n  get opacity() {\n    // use ?? since 0 is falsy, || would return rhs in that case\n    return +(this._opacity ?? this.getAttribute('opacity'));\n  }\n\n  set opacity(val) {\n    if (+val > 1 || +val < 0) return;\n    this.setAttribute('opacity', val);\n  }\n\n  get extent() {\n    // calculate the bounds of all content, return it.\n    if (this._layer && !this._layer.bounds) {\n      this._layer._calculateBounds();\n    }\n    return this._layer\n      ? Object.assign(\n          M._convertAndFormatPCRS(\n            this._layer.bounds,\n            M[this.getProjection()],\n            this.getProjection()\n          ),\n          { zoom: this._layer.zoomBounds }\n        )\n      : null;\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'label':\n          this._layer.setName(newValue);\n          break;\n        case 'checked':\n          if (typeof newValue === 'string') {\n            this.parentElement._map.addLayer(this._layer);\n          } else {\n            this.parentElement._map.removeLayer(this._layer);\n          }\n          this._layerControlCheckbox.checked = this.checked;\n          this.dispatchEvent(new CustomEvent('map-change'));\n          break;\n        case 'hidden':\n          if (typeof newValue === 'string') {\n            this._layerControl.removeLayer(this._layer);\n          } else {\n            this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n            this._validateDisabled();\n          }\n          break;\n        case 'opacity':\n          if (oldValue !== newValue && this._layer) {\n            this._opacity = newValue;\n            this._layer.changeOpacity(newValue);\n          }\n          break;\n        case 'src':\n          if (oldValue !== newValue) {\n            this._onRemove();\n            if (this.isConnected) {\n              this._onAdd();\n            }\n          }\n      }\n    }\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n    // this._opacity is used to record the current opacity value (with or without updates),\n    // the initial value of this._opacity should be set as opacity attribute value, if exists, or the default value 1.0\n    this._opacity = this.opacity || 1.0;\n    this._renderingMapContent = M.options.contentPreference;\n    this.attachShadow({ mode: 'open' });\n  }\n  disconnectedCallback() {\n    // if the map-layer node is removed from the dom, the layer should be\n    // removed from the map and the layer control\n    if (this.hasAttribute('data-moving')) return;\n    this._onRemove();\n  }\n\n  _onRemove() {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n    let l = this._layer,\n      lc = this._layerControl,\n      lchtml = this._layerControlHTML;\n    // remove properties of layer involved in whenReady() logic\n    delete this._layer;\n    delete this._layerControl;\n    delete this._layerControlHTML;\n    delete this._fetchError;\n    this.shadowRoot.innerHTML = '';\n    if (this.src) this.innerHTML = '';\n\n    if (l) {\n      l.off();\n    }\n    // if this layer has never been connected, it will not have a _layer\n    if (l && l._map) {\n      l._map.removeLayer(l);\n    }\n\n    if (lc && !this.hidden) {\n      lc.removeLayer(l);\n    }\n  }\n\n  connectedCallback() {\n    if (this.hasAttribute('data-moving')) return;\n    /* jshint ignore:start */\n    this.#hasConnected = true;\n    /* jshint ignore:end */\n    this._createLayerControlHTML = M._createLayerControlHTML.bind(this);\n    const doConnected = this._onAdd.bind(this);\n    const doRemove = this._onRemove.bind(this);\n    this.parentElement\n      .whenReady()\n      .then(() => {\n        doRemove();\n        doConnected();\n      })\n      .catch((error) => {\n        throw new Error('Map never became ready: ' + error);\n      });\n  }\n\n  _onAdd() {\n    new Promise((resolve, reject) => {\n      this.addEventListener(\n        'changestyle',\n        function (e) {\n          e.stopPropagation();\n          // if user changes the style in layer control\n          if (e.detail) {\n            this._renderingMapContent = e.detail._renderingMapContent;\n            this.src = e.detail.src;\n          }\n        },\n        { once: true }\n      );\n      this.addEventListener(\n        'zoomchangesrc',\n        function (e) {\n          e.stopPropagation();\n          this.src = e.detail.href;\n        },\n        { once: true }\n      );\n      let base = this.baseURI ? this.baseURI : document.baseURI;\n      const headers = new Headers();\n      headers.append('Accept', 'text/mapml');\n      if (this.src && !this.src.endsWith('.pmtiles')) {\n        fetch(this.src, { headers: headers })\n          .then((response) => {\n            if (!response.ok) {\n              throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n            return response.text();\n          })\n          .then((mapml) => {\n            let content = new DOMParser().parseFromString(mapml, 'text/xml');\n            if (\n              content.querySelector('parsererror') ||\n              !content.querySelector('mapml-')\n            ) {\n              // cut short whenReady with the _fetchError property\n              this._fetchError = true;\n              console.log('Error fetching layer content:\\n\\n' + mapml + '\\n');\n              throw new Error('Parser error');\n            }\n            return content;\n          })\n          .then((content) => {\n            this.copyRemoteContentToShadowRoot(content.querySelector('mapml-'));\n            let elements = this.shadowRoot.querySelectorAll('*');\n            let elementsReady = [];\n            for (let i = 0; i < elements.length; i++) {\n              if (elements[i].whenReady)\n                elementsReady.push(elements[i].whenReady());\n            }\n            return Promise.allSettled(elementsReady);\n          })\n          .then(() => {\n            // may throw:\n            this.selectAlternateOrChangeProjection();\n            this.checkForPreferredContent();\n          })\n          .then(() => {\n            this._layer = M.mapMLLayer(new URL(this.src, base).href, this, {\n              projection: this.getProjection(),\n              opacity: this.opacity\n            });\n            this._createLayerControlHTML();\n            this._attachedToMap();\n            // initializing map-features that previously exist\n            this._runMutationObserver(this.shadowRoot.children);\n            this._bindMutationObserver();\n            this._validateDisabled();\n            // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n            // to MapML extent as metadata\n            // Should always be fired at the end of initialization process\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n            // https://maps4html.org/web-map-doc/docs/api/layer-api#events\n            this.dispatchEvent(\n              new CustomEvent('loadedmetadata', { detail: { target: this } })\n            );\n            resolve();\n          })\n          .catch((error) => {\n            reject(error);\n          });\n      } else if (this.src && this.src.endsWith('.pmtiles')) {\n        console.log('Create a MapMLLayer with a pmtiles src');\n        this._layer = M.mapMLLayer(new URL(this.src, base).href, this, {\n          projection: 'OSMTILE',\n          opacity: this.opacity\n        });\n        this._createLayerControlHTML();\n        this._attachedToMap();\n        this._validateDisabled();\n        // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n        // to MapML extent as metadata\n        // Should always be fired at the end of initialization process\n        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n        // https://maps4html.org/web-map-doc/docs/api/layer-api#events\n        this.dispatchEvent(\n          new CustomEvent('loadedmetadata', { detail: { target: this } })\n        );\n      } else {\n        let elements = this.querySelectorAll('*');\n        let elementsReady = [];\n        for (let i = 0; i < elements.length; i++) {\n          if (elements[i].whenReady)\n            elementsReady.push(elements[i].whenReady());\n        }\n        Promise.allSettled(elementsReady)\n          .then(() => {\n            // may throw:\n            this.selectAlternateOrChangeProjection();\n            this.checkForPreferredContent();\n          })\n          .then(() => {\n            this._layer = M.mapMLLayer(null, this, {\n              projection: this.getProjection(),\n              opacity: this.opacity\n            });\n            this._createLayerControlHTML();\n            this._attachedToMap();\n            // initializing map-features that previously exist\n            this._runMutationObserver(this.children);\n            this._bindMutationObserver();\n            this._validateDisabled();\n            // re-use 'loadedmetadata' event from HTMLMediaElement inteface, applied\n            // to MapML extent as metadata\n            // Should always be fired at the end of initialization process\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event\n            // https://maps4html.org/web-map-doc/docs/api/layer-api#events\n            this.dispatchEvent(\n              new CustomEvent('loadedmetadata', { detail: { target: this } })\n            );\n            resolve();\n          })\n          .catch((error) => {\n            reject(error);\n          });\n      }\n    }).catch((e) => {\n      if (e.message === 'changeprojection') {\n        if (e.cause.href) {\n          console.log('Changing layer src to: ' + e.cause.href);\n          this.src = e.cause.href;\n        } else if (e.cause.mapprojection) {\n          console.log(\n            'Changing map projection to match layer: ' + e.cause.mapprojection\n          );\n          this.parentElement.projection = e.cause.mapprojection;\n        }\n      } else if (e.message === 'findmatchingpreferredcontent') {\n        if (e.cause.href) {\n          console.log(\n            'Changing layer to matching preferred content at: ' + e.cause.href\n          );\n          this.src = e.cause.href;\n        }\n      } else if (e.message === 'Failed to fetch') {\n        // cut short whenReady with the _fetchError property\n        this._fetchError = true;\n      } else {\n        console.log(e);\n        this.dispatchEvent(\n          new CustomEvent('error', { detail: { target: this } })\n        );\n      }\n    });\n  }\n\n  selectAlternateOrChangeProjection() {\n    let mapml = this.src ? this.shadowRoot : this;\n    let selectedAlternate =\n      this.getProjection() !== this.parentElement.projection &&\n      mapml.querySelector(\n        'map-link[rel=alternate][projection=' +\n          this.parentElement.projection +\n          '][href]'\n      );\n\n    if (selectedAlternate) {\n      let url = new URL(\n        selectedAlternate.getAttribute('href'),\n        selectedAlternate.getBase()\n      ).href;\n      throw new Error('changeprojection', {\n        cause: { href: url }\n      });\n    }\n    let contentProjection = this.getProjection();\n    if (\n      contentProjection !== this.parentElement.projection &&\n      this.parentElement.layers.length === 1\n    ) {\n      throw new Error('changeprojection', {\n        cause: { mapprojection: contentProjection }\n      });\n    }\n  }\n\n  checkForPreferredContent() {\n    let mapml = this.src ? this.shadowRoot : this;\n    let availablePreferMapContents = mapml.querySelector(\n      `map-link[rel=\"style\"][media=\"prefers-map-content=${this._renderingMapContent}\"][href]`\n    );\n    if (availablePreferMapContents) {\n      // resolve href\n      let url = new URL(\n        availablePreferMapContents.getAttribute('href'),\n        availablePreferMapContents.getBase()\n      ).href;\n      throw new Error('findmatchingpreferredcontent', {\n        cause: { href: url }\n      });\n    }\n  }\n\n  copyRemoteContentToShadowRoot(mapml) {\n    let shadowRoot = this.shadowRoot;\n    // get the map-meta[name=projection/cs/extent/zoom] from map-head of remote mapml, attach them to the shadowroot\n    let frag = document.createDocumentFragment();\n    let elements = mapml.querySelectorAll('map-head > *, map-body > *');\n    for (let i = 0; i < elements.length; i++) {\n      frag.appendChild(elements[i]);\n    }\n    shadowRoot.appendChild(frag);\n  }\n  /**\n   * For \"local\" content, getProjection will use content of \"this\"\n   * For \"remote\" content, you need to pass the shadowRoot to search through\n   */\n  getProjection() {\n    let mapml = this.src ? this.shadowRoot : this;\n    let projection = this.parentElement.projection;\n    if (mapml.querySelector('map-meta[name=projection][content]')) {\n      projection =\n        M._metaContentToObject(\n          mapml\n            .querySelector('map-meta[name=projection]')\n            .getAttribute('content')\n        ).content || projection;\n    } else if (mapml.querySelector('map-extent[units]')) {\n      const getProjectionFrom = (extents) => {\n        let extentProj = extents[0].attributes.units.value;\n        let isMatch = true;\n        for (let i = 0; i < extents.length; i++) {\n          if (extentProj !== extents[i].attributes.units.value) {\n            isMatch = false;\n          }\n        }\n        return isMatch ? extentProj : null;\n      };\n      projection =\n        getProjectionFrom(\n          Array.from(mapml.querySelectorAll('map-extent[units]'))\n        ) || projection;\n    } else {\n      console.log(\n        `A projection was not assigned to the '${mapml.label}' Layer. Please specify a projection for that layer using a map-meta element. See more here - https://maps4html.org/web-map-doc/docs/elements/meta/`\n      );\n    }\n    return projection;\n  }\n  /*\n   * Runs the effects of the mutation observer, which is to add map-features' and\n   * map-extents' leaflet layer implementations to the appropriate container in\n   * the layer-._layer: either as a sub-layer directly in the L.LayerGroup\n   * (MapMLLayer._layer) or as a sub-layer in the MapMLLayer._mapmlvectors\n   * L.FeatureGroup\n   */\n  _runMutationObserver(elementsGroup) {\n    const _addFeatureToMapMLVectors = (feature) => {\n      this.whenReady().then(() => {\n        // the layer extent must change as features are added, this.extent\n        // property only recalculates the bounds and zoomBounds when .bounds\n        // doesn't exist, so delete it to ensure that the extent is reset\n        delete this._layer.bounds;\n        feature.addFeature(this._layer._mapmlvectors);\n      });\n    };\n    const _addStylesheetLink = (mapLink) => {\n      this.whenReady().then(() => {\n        this._layer.appendStyleLink(mapLink);\n      });\n    };\n    const _addStyleElement = (mapStyle) => {\n      this.whenReady().then(() => {\n        this._layer.appendStyleElement(mapStyle);\n      });\n    };\n    const _addExtentElement = (mapExtent) => {\n      this.whenReady().then(() => {\n        // see comment regarding features / extent. Same thing applies to\n        // map-extent\n        delete this._layer.bounds;\n        this._validateDisabled();\n      });\n    };\n    // is this really necessary?  Do we believe that remote mapml documents will\n    // be interactive i.e. script access to their DOM?\n    let root = this.src ? this.shadowRoot : this,\n      pseudo = root instanceof ShadowRoot ? ':host' : ':scope';\n    const _addMetaElement = (mapMeta) => {\n      this.whenReady().then(() => {\n        this._layer._calculateBounds();\n        this._validateDisabled();\n      });\n    };\n    for (let i = 0; i < elementsGroup.length; ++i) {\n      let element = elementsGroup[i];\n      switch (element.nodeName) {\n        case 'MAP-FEATURE':\n          _addFeatureToMapMLVectors(element);\n          break;\n        case 'MAP-LINK':\n          if (element.link && !element.link.isConnected)\n            _addStylesheetLink(element);\n          break;\n        case 'MAP-STYLE':\n          if (element.styleElement && !element.styleElement.isConnected) {\n            _addStyleElement(element);\n          }\n          break;\n        case 'MAP-EXTENT':\n          _addExtentElement(element);\n          break;\n        case 'MAP-META':\n          // to consider: should we only honour the first child map-meta of a\n          // given name value? i.e. run _addMetaElement only for\n          // this.querySelector('map-meta[name=zoom]')\n          // tbd will this do it: element === this.querySelector(`[name=${element.getAttribute('name')}]`)\n          // a no, it will need to take into account src/shadowDom\n          const name =\n            element.hasAttribute('name') &&\n            (element.getAttribute('name').toLowerCase() === 'zoom' ||\n              element.getAttribute('name').toLowerCase() === 'extent');\n          if (\n            name &&\n            element ===\n              root.querySelector(\n                `${pseudo} > [name=${element.getAttribute('name')}]`\n              ) &&\n            element.hasAttribute('content')\n          ) {\n            _addMetaElement(element);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  /*\n   * Set up a function to watch additions of child elements of layer- or\n   * layer-.shadowRoot and to invoke desired side  effects of those additions\n   * via _runMutationObserver\n   */\n  _bindMutationObserver() {\n    // mutation observer\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes should be handled by attributeChangedCallback()\n        if (mutation.type === 'childList') {\n          this._runMutationObserver(mutation.addedNodes);\n        }\n      }\n    });\n    this._observer.observe(this.src ? this.shadowRoot : this, {\n      childList: true\n    });\n  }\n  _attachedToMap() {\n    // set i to the position of this layer element in the set of layers\n    var i = 0,\n      position = 1;\n    for (var nodes = this.parentNode.children; i < nodes.length; i++) {\n      if (this.parentNode.children[i].nodeName === 'LAYER-') {\n        if (this.parentNode.children[i] === this) {\n          position = i + 1;\n        } else if (this.parentNode.children[i]._layer) {\n          this.parentNode.children[i]._layer.setZIndex(i + 1);\n        }\n      }\n    }\n    var proj = this.parentNode.projection\n      ? this.parentNode.projection\n      : 'OSMTILE';\n    L.setOptions(this._layer, {\n      zIndex: position,\n      mapprojection: proj,\n      opacity: window.getComputedStyle(this).opacity\n    });\n    // make sure the Leaflet layer has a reference to the map\n    this._layer._map = this.parentNode._map;\n\n    if (this.checked) {\n      this._layer.addTo(this._layer._map);\n    }\n\n    this._layer.on('add remove', this._validateDisabled, this);\n    // toggle the this.disabled attribute depending on whether the layer\n    // is: same prj as map, within view/zoom of map\n    this._layer._map.on('moveend layeradd', this._validateDisabled, this);\n\n    if (this.parentNode._layerControl)\n      this._layerControl = this.parentNode._layerControl;\n    // if controls option is enabled, insert the layer into the overlays array\n    if (this.parentNode._layerControl && !this.hidden) {\n      this._layerControl.addOrUpdateOverlay(this._layer, this.label);\n    }\n\n    // the mapml document associated to this layer can in theory contain many\n    // link[@rel=legend] elements with different @type or other attributes;\n    // currently only support a single link, don't care about type, lang etc.\n    // TODO: add support for full LayerLegend object, and > one link.\n    if (this._layer._legendUrl) {\n      this.legendLinks = [\n        {\n          type: 'application/octet-stream',\n          href: this._layer._legendUrl,\n          rel: 'legend',\n          lang: null,\n          hreflang: null,\n          sizes: null\n        }\n      ];\n    }\n  }\n\n  _validateDisabled() {\n    // setTimeout is necessary to make the validateDisabled happen later than the moveend operations etc.,\n    // to ensure that the validated result is correct\n    setTimeout(() => {\n      let layer = this._layer,\n        map = layer?._map;\n      if (map) {\n        this._validateLayerZoom({ zoom: map.getZoom() });\n        // prerequisite: no inline and remote mapml elements exists at the same time\n        const mapExtents = this.src\n          ? this.shadowRoot.querySelectorAll('map-extent')\n          : this.querySelectorAll('map-extent');\n        let extentLinksReady = [];\n        for (let i = 0; i < mapExtents.length; i++) {\n          extentLinksReady.push(mapExtents[i].whenLinksReady());\n        }\n        Promise.allSettled(extentLinksReady)\n          .then(() => {\n            let disabledExtentCount = 0,\n              totalExtentCount = 0,\n              layerTypes = [\n                '_staticTileLayer',\n                '_mapmlvectors',\n                '_extentLayer'\n              ];\n            for (let j = 0; j < layerTypes.length; j++) {\n              let type = layerTypes[j];\n              if (this.checked) {\n                if (type === '_extentLayer' && mapExtents.length > 0) {\n                  for (let i = 0; i < mapExtents.length; i++) {\n                    totalExtentCount++;\n                    if (mapExtents[i]._validateDisabled())\n                      disabledExtentCount++;\n                  }\n                } else if (layer[type]) {\n                  // not a templated layer\n                  totalExtentCount++;\n                  if (!layer[type].isVisible()) disabledExtentCount++;\n                }\n              }\n            }\n            // if all extents are not visible / disabled, set layer to disabled\n            if (\n              disabledExtentCount === totalExtentCount &&\n              disabledExtentCount !== 0\n            ) {\n              this.setAttribute('disabled', '');\n              this.disabled = true;\n            } else {\n              this.removeAttribute('disabled');\n              this.disabled = false;\n            }\n            this.toggleLayerControlDisabled();\n          })\n          .catch((e) => {\n            console.log(e);\n          });\n      }\n    }, 0);\n  }\n  _validateLayerZoom(e) {\n    // get the min and max zooms from all extents\n    let toZoom = e.zoom;\n    let min = this.extent.zoom.minZoom;\n    let max = this.extent.zoom.maxZoom;\n    let inLink = this.src\n        ? this.shadowRoot.querySelector('map-link[rel=zoomin]')\n        : this.querySelector('map-link[rel=zoomin]'),\n      outLink = this.src\n        ? this.shadowRoot.querySelector('map-link[rel=zoomout]')\n        : this.querySelector('map-link[rel=zoomout]');\n    let targetURL;\n    if (!(min <= toZoom && toZoom <= max)) {\n      if (inLink && toZoom > max) {\n        targetURL = inLink.href;\n      } else if (outLink && toZoom < min) {\n        targetURL = outLink.href;\n      }\n      if (targetURL) {\n        this.dispatchEvent(\n          new CustomEvent('zoomchangesrc', {\n            detail: {\n              href: targetURL\n            }\n          })\n        );\n      }\n    }\n  }\n  // disable/italicize layer control elements based on the layer-.disabled property\n  toggleLayerControlDisabled() {\n    let input = this._layerControlCheckbox,\n      label = this._layerControlLabel,\n      opacityControl = this._opacityControl,\n      opacitySlider = this._opacitySlider,\n      styleControl = this._styles;\n    if (this.disabled) {\n      input.disabled = true;\n      opacitySlider.disabled = true;\n      label.style.fontStyle = 'italic';\n      opacityControl.style.fontStyle = 'italic';\n      if (styleControl) {\n        styleControl.style.fontStyle = 'italic';\n        styleControl.querySelectorAll('input').forEach((i) => {\n          i.disabled = true;\n        });\n      }\n    } else {\n      input.disabled = false;\n      opacitySlider.disabled = false;\n      label.style.fontStyle = 'normal';\n      opacityControl.style.fontStyle = 'normal';\n      if (styleControl) {\n        styleControl.style.fontStyle = 'normal';\n        styleControl.querySelectorAll('input').forEach((i) => {\n          i.disabled = false;\n        });\n      }\n    }\n  }\n  queryable() {\n    let content = this.src ? this.shadowRoot : this;\n    return (\n      content.querySelector('map-extent[checked] > map-link[rel=query]') &&\n      this.checked &&\n      this._layer &&\n      !this.hidden\n    );\n  }\n  getAlternateStyles(styleLinks) {\n    if (styleLinks.length > 1) {\n      var stylesControl = document.createElement('details'),\n        stylesControlSummary = document.createElement('summary');\n      stylesControlSummary.innerText = 'Style';\n      stylesControl.appendChild(stylesControlSummary);\n\n      for (var j = 0; j < styleLinks.length; j++) {\n        stylesControl.appendChild(styleLinks[j].getLayerControlOption());\n        L.DomUtil.addClass(\n          stylesControl,\n          'mapml-layer-item-style mapml-control-layers'\n        );\n      }\n      return stylesControl;\n    }\n  }\n  getOuterHTML() {\n    let tempElement = this.cloneNode(true);\n\n    if (this.hasAttribute('src')) {\n      let newSrc = this._layer.getHref();\n      tempElement.setAttribute('src', newSrc);\n    }\n    if (this.querySelector('map-link')) {\n      let mapLinks = tempElement.querySelectorAll('map-link');\n\n      mapLinks.forEach((mapLink) => {\n        if (mapLink.hasAttribute('href')) {\n          mapLink.setAttribute(\n            'href',\n            decodeURI(\n              new URL(\n                mapLink.attributes.href.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        } else if (mapLink.hasAttribute('tref')) {\n          mapLink.setAttribute(\n            'tref',\n            decodeURI(\n              new URL(\n                mapLink.attributes.tref.value,\n                this.baseURI ? this.baseURI : document.baseURI\n              ).href\n            )\n          );\n        }\n      });\n    }\n\n    let outerLayer = tempElement.outerHTML;\n\n    tempElement.remove();\n\n    return outerLayer;\n  }\n\n  zoomTo() {\n    this.whenReady().then(() => {\n      let map = this.parentElement._map,\n        extent = this.extent,\n        tL = extent.topLeft.pcrs,\n        bR = extent.bottomRight.pcrs,\n        layerBounds = L.bounds(\n          L.point(tL.horizontal, tL.vertical),\n          L.point(bR.horizontal, bR.vertical)\n        ),\n        center = map.options.crs.unproject(layerBounds.getCenter(true));\n\n      let maxZoom = extent.zoom.maxZoom,\n        minZoom = extent.zoom.minZoom;\n      map.setView(center, M.getMaxZoom(layerBounds, map, minZoom, maxZoom), {\n        animate: false\n      });\n    });\n  }\n  mapml2geojson(options = {}) {\n    return M.mapml2geojson(this, options);\n  }\n  pasteFeature(feature) {\n    switch (typeof feature) {\n      case 'string':\n        feature.trim();\n        if (\n          feature.slice(0, 12) === '<map-feature' &&\n          feature.slice(-14) === '</map-feature>'\n        ) {\n          this.insertAdjacentHTML('beforeend', feature);\n        }\n        break;\n      case 'object':\n        if (feature.nodeName.toUpperCase() === 'MAP-FEATURE') {\n          this.appendChild(feature);\n        }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (\n        this._layer &&\n        this._layerControlHTML &&\n        (!this.src || this.shadowRoot?.childNodes.length)\n      ) {\n        resolve();\n      } else {\n        let layerElement = this;\n        interval = setInterval(testForLayer, 200, layerElement);\n        failureTimer = setTimeout(layerNotDefined, 5000);\n      }\n      function testForLayer(layerElement) {\n        if (\n          layerElement._layer &&\n          layerElement._layerControlHTML &&\n          (!layerElement.src || layerElement.shadowRoot?.childNodes.length)\n        ) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (layerElement._fetchError) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('Error fetching layer content');\n        }\n      }\n      function layerNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for layer to be ready');\n      }\n    });\n  }\n  // check if all child elements are ready\n  whenElemsReady() {\n    let elemsReady = [];\n    let target = this.src ? this.shadowRoot : this;\n    for (let elem of [\n      ...target.querySelectorAll('map-extent'),\n      ...target.querySelectorAll('map-feature')\n    ]) {\n      elemsReady.push(elem.whenReady());\n    }\n    return Promise.allSettled(elemsReady);\n  }\n}\n"],"names":["MapLayer","HTMLElement","observedAttributes","#hasConnected","src","this","hasAttribute","getAttribute","val","setAttribute","label","_layer","getName","checked","removeAttribute","hidden","opacity","_opacity","extent","bounds","_calculateBounds","Object","assign","M","_convertAndFormatPCRS","getProjection","zoom","zoomBounds","attributeChangedCallback","name","oldValue","newValue","setName","parentElement","_map","addLayer","removeLayer","_layerControlCheckbox","dispatchEvent","CustomEvent","_layerControl","addOrUpdateOverlay","_validateDisabled","changeOpacity","_onRemove","isConnected","_onAdd","constructor","super","_renderingMapContent","options","contentPreference","attachShadow","mode","disconnectedCallback","_observer","disconnect","let","l","lc","_layerControlHTML","_fetchError","shadowRoot","innerHTML","off","connectedCallback","_createLayerControlHTML","bind","doConnected","doRemove","whenReady","then","catch","Error","error","Promise","resolve","reject","addEventListener","e","stopPropagation","detail","once","href","base","baseURI","document","headers","Headers","append","endsWith","fetch","response","ok","status","text","content","DOMParser","parseFromString","mapml","querySelector","console","log","copyRemoteContentToShadowRoot","elements","querySelectorAll","elementsReady","i","length","push","allSettled","selectAlternateOrChangeProjection","checkForPreferredContent","mapMLLayer","URL","projection","_attachedToMap","_runMutationObserver","children","_bindMutationObserver","target","message","cause","mapprojection","selectedAlternate","url","getBase","contentProjection","layers","availablePreferMapContents","frag","createDocumentFragment","appendChild","_metaContentToObject","extentProj","extents","attributes","units","value","isMatch","getProjectionFrom","Array","from","elementsGroup","_addFeatureToMapMLVectors","feature","addFeature","_mapmlvectors","_addStylesheetLink","appendStyleLink","mapLink","_addStyleElement","appendStyleElement","mapStyle","_addExtentElement","root","pseudo","ShadowRoot","_addMetaElement","element","nodeName","link","styleElement","toLowerCase","MutationObserver","mutation","mutationList","type","addedNodes","observe","childList","position","nodes","parentNode","setZIndex","proj","L","setOptions","zIndex","window","getComputedStyle","addTo","on","_legendUrl","legendLinks","rel","lang","hreflang","sizes","setTimeout","layer","map","_validateLayerZoom","getZoom","mapExtents","extentLinksReady","whenLinksReady","disabledExtentCount","totalExtentCount","layerTypes","j","isVisible","disabled","toggleLayerControlDisabled","toZoom","min","minZoom","max","maxZoom","inLink","outLink","targetURL","input","_layerControlLabel","opacityControl","_opacityControl","opacitySlider","_opacitySlider","styleControl","_styles","style","fontStyle","forEach","queryable","getAlternateStyles","styleLinks","stylesControl","createElement","stylesControlSummary","innerText","getLayerControlOption","DomUtil","addClass","getOuterHTML","tempElement","cloneNode","newSrc","getHref","mapLinks","decodeURI","tref","outerLayer","outerHTML","remove","zoomTo","tL","topLeft","pcrs","bR","bottomRight","layerBounds","point","horizontal","vertical","center","crs","unproject","getCenter","setView","getMaxZoom","animate","mapml2geojson","pasteFeature","trim","slice","insertAdjacentHTML","toUpperCase","interval","failureTimer","childNodes","setInterval","layerElement","clearInterval","clearTimeout","whenElemsReady","elemsReady","elem"],"mappings":"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"}