{"version":3,"file":"map-link.js","sources":["../src/map-link.js"],"sourcesContent":["/* global M */\n\nexport class MapLink extends HTMLElement {\n  static get observedAttributes() {\n    return [\n      'type',\n      'rel',\n      //      'title',\n      'media',\n      'href',\n      'hreflang',\n      'tref',\n      'tms',\n      'projection'\n    ];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get type() {\n    return this.getAttribute('type') || 'image/*';\n  }\n  set type(val) {\n    // improve this\n    if (\n      val === 'text/mapml' ||\n      val.startsWith('image/' || val === 'application/pmtiles')\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  get rel() {\n    // rel value has no default value\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel#:~:text=The%20rel%20attribute%20has%20no%20default%20value.\n    return this.getAttribute('rel');\n  }\n  set rel(val) {\n    // improve this\n    if (\n      [\n        'license',\n        'alternate',\n        'self',\n        'style',\n        'tile',\n        'image',\n        'features',\n        'zoomin',\n        'zoomout',\n        'legend',\n        'query',\n        'stylesheet'\n      ].includes(val)\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  //  get title() {\n  //    return this.getAttribute('title');\n  //  }\n  //  set title(val) {\n  //    if (val) {\n  //      this.setAttribute('title', val);\n  //    }\n  //  }\n  get href() {\n    if (this.hasAttribute('href')) {\n      return new URL(this.getAttribute('href'), this.getBase()).href;\n    } else if (this.hasAttribute('tref')) {\n      return this.resolve();\n    }\n  }\n  set href(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('href', val);\n    }\n  }\n  get hreflang() {\n    return this.getAttribute('hreflang');\n  }\n  set hreflang(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('hreflang', val);\n    }\n  }\n  get tref() {\n    if (!this.hasAttribute('tref')) {\n      return M.BLANK_TT_TREF;\n    }\n    return this.getAttribute('tref');\n  }\n  set tref(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tref', val);\n    }\n  }\n  get media() {\n    // return the content of media attribute as an object\n    // maybe memoizing the object to avoid repeated formatting\n    // the Util function may need to be renamed?\n    return M._metaContentToObject(this.getAttribute('media'));\n  }\n  set media(val) {\n    this.setAttribute('media', val);\n  }\n  get tms() {\n    return this.hasAttribute('tms');\n  }\n  set tms(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tms', '');\n    }\n  }\n  get projection() {\n    return this.getAttribute('projection');\n  }\n  set projection(val) {\n    // improve this\n    if (['OSMTILE', 'CBMTILE', 'WGS84', 'APSTILE'].includes(val)) {\n      this.setAttribute('projection', val);\n    }\n  }\n  get extent() {\n    // calculate the bounds of content, return it.\n    // _templateVars existence happens for both templated layers and query links\n    return this._templateVars\n      ? Object.assign(\n          M._convertAndFormatPCRS(\n            this.getBounds(),\n            M[this.parentExtent.units],\n            this.parentExtent.units\n          ),\n          { zoom: this.getZoomBounds() }\n        )\n      : null;\n  }\n  zoomTo() {\n    let extent = this.extent;\n    if (!extent) return;\n    let map = this.getMapEl()._map,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      bounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax)),\n      center = map.options.crs.unproject(bounds.getCenter(true)),\n      maxZoom = extent.zoom.maxZoom,\n      minZoom = extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(bounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  getMapEl() {\n    return M.getClosest(this, 'mapml-viewer,map[is=web-map]');\n  }\n  getLayerEl() {\n    return M.getClosest(this, 'layer-');\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    //['type','rel','href','hreflang','tref','tms','projection'];\n    // fold to lowercase\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'type':\n          // rel = tile, features, etc. TBD when it is used\n          //        ttype = !t.hasAttribute('type')\n          //          ? 'image/*'\n          //          : t.getAttribute('type').toLowerCase(),\n\n          if (oldValue !== newValue) {\n            // default value image/*\n            // handle side effects\n          }\n          break;\n        case 'rel':\n          // mandatory attribute, no default value\n          if (oldValue !== newValue) {\n            // handle side effects\n            if (newValue === 'query') {\n            }\n          }\n          break;\n        //      case 'title':\n        //        if (oldValue !== newValue) {\n        //          // handle side effects\n        //        }\n        //        break;\n        case 'href':\n          // rel = license, legend, stylesheet, self, style, self style, style self, zoomin, zoomout\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'hreflang':\n          // rel = *all*\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#hreflang\n          // idea is that we can have multiple map-links with different hreflang, and map-extent chooses a map-link that matches with user's lang. Not a priority. - create an use-case issue?\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'tref':\n          // rel = tile, image, features, query\n          if (oldValue !== newValue) {\n            // create or reset the _templateVars property\n            this._initTemplateVars();\n          }\n          break;\n        case 'media':\n          break;\n        case 'tms':\n          // rel = tile\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'projection':\n          // rel = alternate\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n      }\n    }\n  }\n  _definePMTilesRules() {\n    class SpearfishSymbolizer {\n      constructor(options) {\n        this.color = options.color;\n        this.shape = options.shape;\n      }\n      draw(context, geom, z, feature) {\n        let pt = geom[0][0];\n        context.fillStyle = this.color;\n        context.strokeStyle = this.color;\n        context.beginPath();\n        if (this.shape === 'circle') {\n          context.arc(pt.x, pt.y, 3, 0, 2 * Math.PI);\n        } else {\n          context.rect(pt.x - 2, pt.y - 2, 4, 4);\n        }\n        context.stroke();\n        context.fill();\n      }\n    }\n    if (Boolean(this.tref.match(/geoserver/))) {\n      // how to make rules into a callack API??\n      this.RULES = {\n        PAINT_RULES: [\n          {\n            dataLayer: 'streams',\n            symbolizer: new M.LineSymbolizer({ color: 'steelblue', width: 2 })\n          },\n          {\n            dataLayer: 'roads',\n            symbolizer: new M.LineSymbolizer({ color: 'maroon', width: 2 })\n          },\n          {\n            dataLayer: 'restricted',\n            symbolizer: new M.PolygonSymbolizer({\n              fill: 'red',\n              opacity: 0.5\n            })\n          },\n          {\n            dataLayer: 'restricted',\n            symbolizer: new M.LineSymbolizer({ color: 'red', width: 2 })\n          },\n          {\n            dataLayer: 'archsites',\n            symbolizer: new SpearfishSymbolizer({\n              color: 'red',\n              shape: 'square'\n            })\n          },\n          {\n            dataLayer: 'bugsites',\n            symbolizer: new SpearfishSymbolizer({\n              color: 'black',\n              shape: 'circle'\n            })\n          }\n        ],\n        LABEL_RULES: []\n      };\n    } else {\n      this.THEME = 'light';\n    }\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  connectedCallback() {\n    this.#hasConnected = true; /* jshint ignore:line */\n    if (\n      this.getLayerEl().hasAttribute('data-moving') ||\n      (this.parentExtent && this.parentExtent.hasAttribute('data-moving'))\n    )\n      return;\n    this._definePMTilesRules();\n    switch (this.rel.toLowerCase()) {\n      // for some cases, require a dependency check\n      case 'tile':\n      case 'image':\n      case 'features':\n      case 'query':\n        this._initTemplateVars();\n        this._createTemplatedLink();\n        break;\n      case 'style':\n      case 'self':\n      case 'style self':\n      case 'self style':\n        this._createSelfOrStyleLink();\n        break;\n      case 'zoomin':\n      case 'zoomout':\n        //        this._createZoominOrZoomoutLink();\n        break;\n      case 'legend':\n        //this._createLegendLink();\n        break;\n      case 'stylesheet':\n        this._createStylesheetLink();\n        break;\n      case 'alternate':\n        this._createAlternateLink(); // add media attribute\n        break;\n      case 'license':\n        // this._createLicenseLink();\n        break;\n    }\n    // create the type of templated leaflet layer appropriate to the rel value\n    // image/map/features = templated(Image/Feature), tile=templatedTile,\n    // this._tempatedTileLayer = M.templatedTile(pane: this.extentElement._leafletLayer._container)\n    // add to viewer._map dependant on map-extent.checked, layer-.checked\n    // what else?\n  }\n  disconnectedCallback() {\n    switch (this.rel.toLowerCase()) {\n      case 'stylesheet':\n        if (this._stylesheetHost) {\n          this.link.remove();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  _createAlternateLink(mapml) {\n    if (this.href && this.projection) this._alternate = true;\n  }\n  _createStylesheetLink() {\n    // if the parent element is a map-link, the stylesheet is a link that should\n    //  be loaded as part of a templated layer processing i.e. on moveend\n    //  and the generated <link> that implements this <map-link> should be located\n    //  in the parent <map-link>._templatedLayer.container root node if\n    //  the _templatedLayer is an instance of M.TemplatedTileLayer or M.TemplatedFeaturesLayer\n    //\n    // if the parent node (or the host of the shadow root parent node) is layer-, the link should be created in the _layer\n    // container\n    this._stylesheetHost =\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().host\n        : this.parentElement;\n    if (this._stylesheetHost === undefined) return;\n\n    this.link = document.createElement('link');\n    this.link.mapLink = this;\n    this.link.setAttribute('href', new URL(this.href, this.getBase()).href);\n    copyAttributes(this, this.link);\n\n    if (this._stylesheetHost._layer) {\n      this._stylesheetHost._layer.appendStyleLink(this);\n    } else if (this._stylesheetHost._templatedLayer) {\n      this._stylesheetHost._templatedLayer.appendStyleLink(this);\n    } else if (this._stylesheetHost._extentLayer) {\n      this._stylesheetHost._extentLayer.appendStyleLink(this);\n    }\n\n    function copyAttributes(source, target) {\n      return Array.from(source.attributes).forEach((attribute) => {\n        if (attribute.nodeName !== 'href')\n          target.setAttribute(attribute.nodeName, attribute.nodeValue);\n      });\n    }\n  }\n\n  async _createTemplatedLink() {\n    // conditions check\n    // the tms and type attributes are optional, may need to be checked in future\n    this.parentExtent =\n      this.parentNode.nodeName.toUpperCase() === 'MAP-EXTENT'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (!this.tref || !this.parentExtent) return;\n    try {\n      await this.parentExtent.whenReady();\n      await this._templateVars.inputsReady;\n    } catch (error) {\n      console.log('Error while creating templated link: ' + error);\n      return;\n    }\n    this.mapEl = this.getMapEl();\n    // create the layer type appropriate to the rel value\n    this.zIndex = Array.from(\n      this.parentExtent.querySelectorAll(\n        'map-link[rel=image],map-link[rel=tile],map-link[rel=features]'\n      )\n    ).indexOf(this);\n    if (\n      (this.rel === 'tile' && this.type === 'application/pmtiles') ||\n      this.type === 'application/vnd.mapbox-vector-tile'\n    ) {\n      let options = {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      };\n      if (this.RULES) {\n        options.PAINT_RULES = this.RULES.PAINT_RULES;\n        options.LABEL_RULES = this.RULES.LABEL_RULES;\n      } else if (this.THEME) {\n        options.THEME = this.THEME;\n      }\n      // create a pmtiles leaflet layer\n\n      this._templatedLayer = M.templatedPMTilesLayer(\n        this._templateVars,\n        options\n      ).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'tile') {\n      this._templatedLayer = M.templatedTileLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        errorTileUrl:\n          'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'image') {\n      this._templatedLayer = M.templatedImageLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'features') {\n      // map-feature retrieved by link will be stored in shadowRoot owned by link\n      this.attachShadow({ mode: 'open' });\n      this._templatedLayer = M.templatedFeaturesLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'query') {\n      this.attachShadow({ mode: 'open' });\n      L.extend(this._templateVars, this._setupQueryVars(this._templateVars));\n      L.extend(this._templateVars, { extentBounds: this.getBounds() });\n    }\n  }\n  _setupQueryVars(template) {\n    // process the inputs associated to template and create an object named\n    // query with member properties as follows:\n    // {width: 'widthvarname',\n    //  height: 'heightvarname',\n    //  left: 'leftvarname',\n    //  right: 'rightvarname',\n    //  top: 'topvarname',\n    //  bottom: 'bottomvarname'\n    //  i: 'ivarname'\n    //  j: 'jvarname'}\n    //  x: 'xvarname' x being the tcrs x axis\n    //  y: 'yvarname' y being the tcrs y axis\n    //  z: 'zvarname' zoom\n    //  title: link title\n\n    var queryVarNames = { query: {} },\n      inputs = template.values;\n\n    for (var i = 0; i < template.values.length; i++) {\n      var type = inputs[i].getAttribute('type'),\n        units = inputs[i].getAttribute('units'),\n        axis = inputs[i].getAttribute('axis'),\n        name = inputs[i].getAttribute('name'),\n        position = inputs[i].getAttribute('position'),\n        rel = inputs[i].getAttribute('rel'),\n        select = inputs[i].tagName.toLowerCase() === 'map-select';\n      if (type === 'width') {\n        queryVarNames.query.width = name;\n      } else if (type === 'height') {\n        queryVarNames.query.height = name;\n      } else if (type === 'location') {\n        switch (axis) {\n          case 'x':\n          case 'y':\n          case 'column':\n          case 'row':\n            queryVarNames.query[axis] = name;\n            break;\n          case 'longitude':\n          case 'easting':\n            if (position) {\n              if (position.match(/.*?-left/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelleft = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileleft = name;\n                } else {\n                  queryVarNames.query.mapleft = name;\n                }\n              } else if (position.match(/.*?-right/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelright = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileright = name;\n                } else {\n                  queryVarNames.query.mapright = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'latitude':\n          case 'northing':\n            if (position) {\n              if (position.match(/top-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixeltop = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tiletop = name;\n                } else {\n                  queryVarNames.query.maptop = name;\n                }\n              } else if (position.match(/bottom-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelbottom = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tilebottom = name;\n                } else {\n                  queryVarNames.query.mapbottom = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'i':\n            if (units === 'tile') {\n              queryVarNames.query.tilei = name;\n            } else {\n              queryVarNames.query.mapi = name;\n            }\n            break;\n          case 'j':\n            if (units === 'tile') {\n              queryVarNames.query.tilej = name;\n            } else {\n              queryVarNames.query.mapj = name;\n            }\n            break;\n          default:\n          // unsuportted axis value\n        }\n      } else if (type === 'zoom') {\n        //<input name=\"...\" type=\"zoom\" value=\"0\" min=\"0\" max=\"17\">\n        queryVarNames.query.zoom = name;\n      } else if (select) {\n        /*jshint -W104 */\n        const parsedselect = inputs[i].htmlselect;\n        queryVarNames.query[name] = function () {\n          return parsedselect.value;\n        };\n      } else {\n        /*jshint -W104 */\n        const input = inputs[i];\n        queryVarNames.query[name] = function () {\n          return input.getAttribute('value');\n        };\n      }\n    }\n    return queryVarNames;\n  }\n  _initTemplateVars() {\n    // set up the URL template and associated inputs (which yield variable values when processed)\n    var varNamesRe = new RegExp('(?:{)(.*?)(?:})', 'g'),\n      zoomInput = this.parentElement.querySelector('map-input[type=\"zoom\" i]'),\n      includesZoom = false,\n      linkedZoomInput;\n\n    var template = this.tref;\n    if (template === M.BLANK_TT_TREF) {\n      for (let i of this.parentElement.querySelectorAll('map-input')) {\n        template += `{${i.getAttribute('name')}}`;\n      }\n    }\n    this.zoomInput = zoomInput;\n\n    var v,\n      vcount = template.match(varNamesRe) || [],\n      inputs = [],\n      inputsReady = [];\n    while ((v = varNamesRe.exec(template)) !== null) {\n      let varName = v[1],\n        inp = this.parentElement.querySelector(\n          'map-input[name=' + varName + '],map-select[name=' + varName + ']'\n        );\n      if (inp) {\n        // this \"associates\" the input to this  map-link\n        inputs.push(inp);\n        inputsReady.push(inp.whenReady());\n\n        // I think this means that regardless of whether the tref includes\n        // a reference to the zoom input, it gets associated to the link\n        // and used (to specify the native zoom bounds??) for the templated(Tile|Image|Features)Layer\n        if (\n          inp.hasAttribute('type') &&\n          inp.getAttribute('type').toLowerCase() === 'zoom'\n        ) {\n          linkedZoomInput = inp;\n          includesZoom = true;\n        }\n        // moved a block to map-select to transcribe the map-select into an\n        // actual html select for inclusion in the layer control.\n\n        // TODO: if this is an input@type=location\n        // get the TCRS min,max attribute values at the identified zoom level\n        // save this information as properties of the mapExtent,\n        // perhaps as a bounds object so that it can be easily used\n        // later by the layer control to determine when to enable\n        // disable the layer for drawing.\n      } else {\n        console.log(\n          'input with name=' +\n            varName +\n            ' not found for template variable of same name'\n        );\n      }\n    }\n    if (template && vcount.length === inputs.length) {\n      if (!includesZoom && zoomInput) {\n        inputs.push(zoomInput);\n        linkedZoomInput = zoomInput;\n      }\n      let step = zoomInput ? zoomInput.getAttribute('step') : 1;\n      if (!step || step === '0' || isNaN(step)) step = 1;\n      // template has a matching input for every variable reference {varref}\n      this._templateVars = {\n        template: decodeURI(new URL(template, this.getBase())),\n        linkEl: this,\n        rel: this.rel,\n        type: this.type,\n        values: inputs,\n        inputsReady: Promise.allSettled(inputsReady),\n        zoom: linkedZoomInput,\n        projection: this.parentElement.units,\n        tms: this.tms,\n        step: step\n      };\n    }\n  }\n  getZoomBounds() {\n    return this._getZoomBounds(this._templateVars.zoom);\n  }\n  /**\n   * TODO: review getBounds for sanity, also getFallbackBounds, perhaps integrate\n   * there is no other kind of bounds but native....\n   *  each rectangle must be established and valid and converted to PCRS coordinates...\n    // \"native\" bounds = input type=location min max || map-extent/map-meta name=extent min,max || layer-/map-meta name=extent min,max || layer projection min/max\n */\n  getBounds() {\n    let template = this._templateVars;\n    let inputs = template.values,\n      projection = this.parentElement.units,\n      boundsUnit = {};\n    boundsUnit.name = M.FALLBACK_CS;\n    let bounds = M[projection].options.crs.tilematrix.bounds(0),\n      locInputs = false,\n      numberOfAxes = 0,\n      horizontalAxis = false,\n      verticalAxis = false;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getAttribute('type') === 'location') {\n        if (!inputs[i].getAttribute('max') || !inputs[i].getAttribute('min'))\n          continue;\n        let max = +inputs[i].getAttribute('max'),\n          min = +inputs[i].getAttribute('min');\n        switch (inputs[i].getAttribute('axis').toLowerCase()) {\n          case 'x':\n          case 'longitude':\n          case 'column':\n          case 'easting':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.x = min;\n            bounds.max.x = max;\n            boundsUnit.horizontalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          case 'y':\n          case 'latitude':\n          case 'row':\n          case 'northing':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.y = min;\n            bounds.max.y = max;\n            boundsUnit.verticalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    if (\n      boundsUnit.horizontalAxis &&\n      boundsUnit.verticalAxis &&\n      ((boundsUnit.horizontalAxis === 'x' && boundsUnit.verticalAxis === 'y') ||\n        (boundsUnit.horizontalAxis === 'longitude' &&\n          boundsUnit.verticalAxis === 'latitude') ||\n        (boundsUnit.horizontalAxis === 'column' &&\n          boundsUnit.verticalAxis === 'row') ||\n        (boundsUnit.horizontalAxis === 'easting' &&\n          boundsUnit.verticalAxis === 'northing'))\n    ) {\n      locInputs = true;\n    }\n    if (locInputs) {\n      let zoomValue = this._templateVars.zoom?.hasAttribute('value')\n        ? +this._templateVars.zoom.getAttribute('value')\n        : 0;\n      bounds = M.boundsToPCRSBounds(\n        bounds,\n        zoomValue,\n        projection,\n        boundsUnit.name\n      );\n    } else if (!locInputs) {\n      bounds = this.getFallbackBounds(projection);\n    }\n    return bounds;\n  }\n  getFallbackBounds(projection) {\n    let bounds;\n\n    let zoom = 0;\n    let metaExtent = this.parentElement.getMeta('extent');\n    if (metaExtent) {\n      let content = M._metaContentToObject(metaExtent.getAttribute('content')),\n        cs;\n\n      zoom = content.zoom || zoom;\n\n      let metaKeys = Object.keys(content);\n      for (let i = 0; i < metaKeys.length; i++) {\n        if (!metaKeys[i].includes('zoom')) {\n          cs = M.axisToCS(metaKeys[i].split('-')[2]);\n          break;\n        }\n      }\n      let axes = M.csToAxes(cs);\n      bounds = M.boundsToPCRSBounds(\n        L.bounds(\n          L.point(\n            +content[`top-left-${axes[0]}`],\n            +content[`top-left-${axes[1]}`]\n          ),\n          L.point(\n            +content[`bottom-right-${axes[0]}`],\n            +content[`bottom-right-${axes[1]}`]\n          )\n        ),\n        zoom,\n        projection,\n        cs\n      );\n    } else {\n      let crs = M[projection];\n      bounds = crs.options.crs.pcrs.bounds;\n    }\n    return bounds;\n  }\n  getBase() {\n    let layer = this.getRootNode().host;\n    //\n    let relativeURL =\n      this.getRootNode().querySelector('map-base') &&\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().querySelector('map-base').getAttribute('href')\n        : /* local content? */ !(this.getRootNode() instanceof ShadowRoot)\n        ? /* use the baseURI algorithm which takes into account any <base> */\n          this.getRootNode().querySelector('map-base')?.getAttribute('href') ||\n          this.baseURI\n        : /* else use the resolved <layer- src=\"...\"> value */ new URL(\n            layer.src,\n            layer.baseURI\n          ).href;\n\n    // when remote content, use layer.src as base else use baseURI of map-link\n    let baseURL =\n      this.getRootNode() instanceof ShadowRoot\n        ? new URL(layer.src, layer.baseURI).href\n        : this.baseURI;\n    return new URL(relativeURL, baseURL).href;\n  }\n  /**\n   * Return BOTH min/max(Display)Zoom AND min/maxNativeZoom which\n   * are options that can be passed to L.GridLayer...\n   * https://leafletjs.com/reference.html#gridlayer-minzoom\n   *\n   * @param {Object} zoomInput - is an element reference to a map-input[type=zoom]\n   * @returns {Object} - returns {minZoom: n,maxZoom: n,minNativeZoom: n,maxNativeZoom: n}\n   */\n  _getZoomBounds(zoomInput) {\n    // native variables should ONLY come from map-input min/max attributes\n    // BUT they should fall back to map-meta or projection values for min/max (display) zoom\n    // display zoom variables should be EQUAL to native unless specified differently\n    // via map-meta name=zoom\n    // in particular minNativeZoom being > minZoom can be problematic because\n    // you fetch tiles at larger scales (i.e. many many small tiles) and render\n    // them at smaller scale (i.e. little postage stamps), which can freez your\n    // browser and bury a tile cache in requests, getting you banned/blocked\n    //\n    // minZoom = map-meta name=zoom min || input type=zoom min || projection minZoom\n    // minNativeZoom = input type=zoom min || minZoom\n    // maxZoom = map-meta name=zoom max || input type=zoom max || projection maxZoom\n    // maxNativeZoom = input type=zoom max || maxZoom\n\n    let zoomBounds = {};\n    // search document from here up, using closest source of zoom bounds info\n    let meta = this.parentElement.getMeta('zoom');\n    let metaMin = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.min\n      : null;\n    zoomBounds.minZoom =\n      metaMin || (zoomInput ? +zoomInput.getAttribute('min') : 0);\n    zoomBounds.minNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('min')\n      : zoomBounds.minZoom;\n    let metaMax = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.max\n      : null;\n    zoomBounds.maxZoom =\n      metaMax ||\n      (zoomInput\n        ? +zoomInput.getAttribute('max')\n        : M[this.parentElement.units].options.resolutions.length - 1);\n    zoomBounds.maxNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('max')\n      : zoomBounds.maxZoom;\n\n    return zoomBounds;\n  }\n  _validateDisabled() {\n    let isVisible = false,\n      map = this.getMapEl(),\n      mapZoom = map.zoom,\n      extent = map.extent,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      mapBounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax));\n\n    if (this._templatedLayer) {\n      isVisible = this._templatedLayer.isVisible();\n    } else if (this.rel === 'query') {\n      const minZoom = this.extent.zoom.minZoom,\n        maxZoom = this.extent.zoom.maxZoom,\n        withinZoomBounds = (z) => {\n          return minZoom <= z && z <= maxZoom;\n        };\n\n      if (this.getBounds().overlaps(mapBounds) && withinZoomBounds(mapZoom)) {\n        isVisible = true;\n      }\n    }\n    return isVisible;\n  }\n  _createSelfOrStyleLink() {\n    let layerEl = this.getLayerEl();\n    const changeStyle = function (e) {\n      L.DomEvent.stop(e);\n      layerEl.dispatchEvent(\n        new CustomEvent('changestyle', {\n          detail: {\n            src: e.target.getAttribute('data-href'),\n            preference: this.media['prefers-map-content']\n          }\n        })\n      );\n    };\n\n    let styleOption = document.createElement('div'),\n      styleOptionInput = styleOption.appendChild(\n        document.createElement('input')\n      );\n    styleOptionInput.setAttribute('type', 'radio');\n    styleOptionInput.setAttribute('id', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionInput.setAttribute(\n      'name',\n      // grouping radio buttons based on parent layer's style <detail>\n      'styles-' + L.stamp(styleOption)\n    );\n    styleOptionInput.setAttribute('value', this.getAttribute('title'));\n    styleOptionInput.setAttribute(\n      'data-href',\n      new URL(this.href, this.getBase()).href\n    );\n    var styleOptionLabel = styleOption.appendChild(\n      document.createElement('label')\n    );\n    styleOptionLabel.setAttribute('for', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionLabel.innerText = this.title;\n    if (this.rel === 'style self' || this.rel === 'self style') {\n      styleOptionInput.checked = true;\n    }\n    this._styleOption = styleOption;\n    styleOptionInput.addEventListener('click', changeStyle.bind(this));\n  }\n  getLayerControlOption() {\n    return this._styleOption;\n  }\n\n  // Resolve the templated URL with info from the sibling map-input's\n  resolve() {\n    if (this.tref) {\n      let obj = {};\n      const inputs = this.parentElement.querySelectorAll('map-input');\n      if (this.rel === 'image') {\n        // image/map\n        for (let i = 0; i < inputs.length; i++) {\n          const inp = inputs[i];\n          obj[inp.name] = inp.value;\n        }\n        console.log(obj); // DEBUGGING\n        return L.Util.template(this.tref, obj);\n      } else if (this.rel === 'tile') {\n        // TODO. Need to get tile coords from moveend\n        // should be done/called from the TemplatedTilelayer.js file\n        return obj;\n      } else if (this.rel === 'query') {\n        // TODO. Need to get the click coords from click event\n        // should be done/called from the templatedlayer.js file\n      } else if (this.rel === 'features') {\n        // TODO.\n      }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer, ready;\n      switch (this.rel.toLowerCase()) {\n        // for some cases, require a dependency check\n        case 'tile':\n        case 'image':\n        case 'features':\n          ready = '_templatedLayer';\n          break;\n        case 'style':\n        case 'self':\n        case 'style self':\n        case 'self style':\n          ready = '_styleOption';\n          break;\n        case 'query':\n          ready = 'shadowRoot';\n          break;\n        case 'alternate':\n          ready = '_alternate';\n          break;\n        case 'zoomin':\n        case 'zoomout':\n        case 'legend':\n        case 'stylesheet':\n        case 'license':\n          resolve();\n          break;\n        default:\n          resolve();\n          break;\n      }\n      if (this[ready]) {\n        resolve();\n      }\n      interval = setInterval(testForLinkReady, 300, this);\n      failureTimer = setTimeout(linkNotDefined, 10000);\n      function testForLinkReady(linkElement) {\n        if (linkElement[ready]) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!linkElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-link was disconnected while waiting to be ready');\n        }\n      }\n      function linkNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for link to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapLink","HTMLElement","observedAttributes","#hasConnected","type","this","getAttribute","val","startsWith","setAttribute","rel","includes","href","hasAttribute","URL","getBase","resolve","hreflang","tref","M","BLANK_TT_TREF","media","_metaContentToObject","tms","projection","extent","_templateVars","Object","assign","_convertAndFormatPCRS","getBounds","parentExtent","units","zoom","getZoomBounds","zoomTo","let","map","getMapEl","_map","xmin","topLeft","pcrs","horizontal","xmax","bottomRight","ymin","vertical","ymax","bounds","L","point","center","options","crs","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","getClosest","getLayerEl","attributeChangedCallback","name","oldValue","newValue","_initTemplateVars","_definePMTilesRules","SpearfishSymbolizer","constructor","color","shape","draw","context","geom","z","feature","pt","fillStyle","strokeStyle","beginPath","arc","x","y","Math","PI","rect","stroke","fill","Boolean","match","RULES","PAINT_RULES","dataLayer","symbolizer","LineSymbolizer","width","PolygonSymbolizer","opacity","LABEL_RULES","THEME","super","connectedCallback","toLowerCase","_createTemplatedLink","_createSelfOrStyleLink","_createStylesheetLink","_createAlternateLink","disconnectedCallback","_stylesheetHost","link","remove","mapml","_alternate","source","target","getRootNode","ShadowRoot","host","parentElement","undefined","document","createElement","mapLink","Array","from","attributes","forEach","attribute","nodeName","nodeValue","_layer","appendStyleLink","_templatedLayer","_extentLayer","parentNode","toUpperCase","whenReady","inputsReady","error","console","log","mapEl","zIndex","querySelectorAll","indexOf","zoomBounds","extentBounds","pane","getContainer","linkEl","templatedPMTilesLayer","addTo","templatedTileLayer","errorTileUrl","templatedImageLayer","attachShadow","mode","templatedFeaturesLayer","extend","_setupQueryVars","template","queryVarNames","query","inputs","values","i","length","axis","position","select","tagName","height","pixelleft","tileleft","mapleft","pixelright","tileright","mapright","pixeltop","tiletop","maptop","pixelbottom","tilebottom","mapbottom","tilei","mapi","tilej","mapj","parsedselect","htmlselect","value","input","linkedZoomInput","varNamesRe","RegExp","zoomInput","querySelector","includesZoom","v","vcount","exec","varName","inp","push","step","isNaN","decodeURI","Promise","allSettled","_getZoomBounds","zoomValue","boundsUnit","FALLBACK_CS","tilematrix","locInputs","max","min","axisToCS","horizontalAxis","verticalAxis","boundsToPCRSBounds","getFallbackBounds","metaExtent","getMeta","content","cs","metaKeys","keys","split","axes","csToAxes","layer","relativeURL","src","baseURI","baseURL","meta","metaMin","minNativeZoom","metaMax","resolutions","maxNativeZoom","_validateDisabled","isVisible","mapZoom","mapBounds","overlaps","layerEl","styleOption","styleOptionInput","appendChild","stamp","styleOptionLabel","innerText","title","checked","_styleOption","addEventListener","e","DomEvent","stop","dispatchEvent","CustomEvent","detail","preference","bind","getLayerControlOption","obj","Util","reject","interval","failureTimer","ready","setInterval","linkElement","clearInterval","clearTimeout","isConnected","setTimeout"],"mappings":"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"}