{"version":3,"file":"map-link.js","sources":["../src/map-link.js"],"sourcesContent":["/* global M */\n\nexport class MapLink extends HTMLElement {\n  static get observedAttributes() {\n    return [\n      'type',\n      'rel',\n      //      'title',\n      'media',\n      'href',\n      'hreflang',\n      'tref',\n      'tms',\n      'projection'\n    ];\n  }\n  /* jshint ignore:start */\n  #hasConnected;\n  /* jshint ignore:end */\n  get type() {\n    return this.getAttribute('type') || 'image/*';\n  }\n  set type(val) {\n    // improve this\n    if (\n      val === 'text/mapml' ||\n      val.startsWith('image/' || val === 'application/pmtiles')\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  get rel() {\n    // rel value has no default value\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel#:~:text=The%20rel%20attribute%20has%20no%20default%20value.\n    return this.getAttribute('rel');\n  }\n  set rel(val) {\n    // improve this\n    if (\n      [\n        'license',\n        'alternate',\n        'self',\n        'style',\n        'tile',\n        'image',\n        'features',\n        'zoomin',\n        'zoomout',\n        'legend',\n        'query',\n        'stylesheet'\n      ].includes(val)\n    ) {\n      this.setAttribute('type', val);\n    }\n  }\n  //  get title() {\n  //    return this.getAttribute('title');\n  //  }\n  //  set title(val) {\n  //    if (val) {\n  //      this.setAttribute('title', val);\n  //    }\n  //  }\n  get href() {\n    if (this.hasAttribute('href')) {\n      return new URL(this.getAttribute('href'), this.getBase()).href;\n    } else if (this.hasAttribute('tref')) {\n      return this.resolve();\n    }\n  }\n  set href(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('href', val);\n    }\n  }\n  get hreflang() {\n    return this.getAttribute('hreflang');\n  }\n  set hreflang(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('hreflang', val);\n    }\n  }\n  get tref() {\n    if (!this.hasAttribute('tref')) {\n      return M.BLANK_TT_TREF;\n    }\n    return this.getAttribute('tref');\n  }\n  set tref(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tref', val);\n    }\n  }\n  get media() {\n    // return the content of media attribute as an object\n    // maybe memoizing the object to avoid repeated formatting\n    // the Util function may need to be renamed?\n    return M._metaContentToObject(this.getAttribute('media'));\n  }\n  set media(val) {\n    this.setAttribute('media', val);\n  }\n  get tms() {\n    return this.hasAttribute('tms');\n  }\n  set tms(val) {\n    // improve this\n    if (val) {\n      this.setAttribute('tms', '');\n    }\n  }\n  get projection() {\n    return this.getAttribute('projection');\n  }\n  set projection(val) {\n    // improve this\n    if (['OSMTILE', 'CBMTILE', 'WGS84', 'APSTILE'].includes(val)) {\n      this.setAttribute('projection', val);\n    }\n  }\n  get extent() {\n    // calculate the bounds of content, return it.\n    // _templateVars existence happens for both templated layers and query links\n    return this._templateVars\n      ? Object.assign(\n          M._convertAndFormatPCRS(\n            this.getBounds(),\n            M[this.parentExtent.units],\n            this.parentExtent.units\n          ),\n          { zoom: this.getZoomBounds() }\n        )\n      : null;\n  }\n  zoomTo() {\n    let extent = this.extent;\n    if (!extent) return;\n    let map = this.getMapEl()._map,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      bounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax)),\n      center = map.options.crs.unproject(bounds.getCenter(true)),\n      maxZoom = extent.zoom.maxZoom,\n      minZoom = extent.zoom.minZoom;\n    map.setView(center, M.getMaxZoom(bounds, map, minZoom, maxZoom), {\n      animate: false\n    });\n  }\n  getMapEl() {\n    return M.getClosest(this, 'mapml-viewer,map[is=web-map]');\n  }\n  getLayerEl() {\n    return M.getClosest(this, 'layer-');\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    //['type','rel','href','hreflang','tref','tms','projection'];\n    // fold to lowercase\n    if (this.#hasConnected /* jshint ignore:line */) {\n      switch (name) {\n        case 'type':\n          // rel = tile, features, etc. TBD when it is used\n          //        ttype = !t.hasAttribute('type')\n          //          ? 'image/*'\n          //          : t.getAttribute('type').toLowerCase(),\n\n          if (oldValue !== newValue) {\n            // default value image/*\n            // handle side effects\n          }\n          break;\n        case 'rel':\n          // mandatory attribute, no default value\n          if (oldValue !== newValue) {\n            // handle side effects\n            if (newValue === 'query') {\n            }\n          }\n          break;\n        //      case 'title':\n        //        if (oldValue !== newValue) {\n        //          // handle side effects\n        //        }\n        //        break;\n        case 'href':\n          // rel = license, legend, stylesheet, self, style, self style, style self, zoomin, zoomout\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'hreflang':\n          // rel = *all*\n          // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#hreflang\n          // idea is that we can have multiple map-links with different hreflang, and map-extent chooses a map-link that matches with user's lang. Not a priority. - create an use-case issue?\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'tref':\n          // rel = tile, image, features, query\n          if (oldValue !== newValue) {\n            // create or reset the _templateVars property\n            this._initTemplateVars();\n          }\n          break;\n        case 'media':\n          break;\n        case 'tms':\n          // rel = tile\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n        case 'projection':\n          // rel = alternate\n          if (oldValue !== newValue) {\n            // handle side effects\n          }\n          break;\n      }\n    }\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  connectedCallback() {\n    this.#hasConnected = true; /* jshint ignore:line */\n    if (\n      this.getLayerEl().hasAttribute('data-moving') ||\n      (this.parentExtent && this.parentExtent.hasAttribute('data-moving'))\n    )\n      return;\n    switch (this.rel.toLowerCase()) {\n      // for some cases, require a dependency check\n      case 'tile':\n      case 'image':\n      case 'features':\n      case 'query':\n        this._initTemplateVars();\n        this._createTemplatedLink();\n        break;\n      case 'style':\n      case 'self':\n      case 'style self':\n      case 'self style':\n        this._createSelfOrStyleLink();\n        break;\n      case 'zoomin':\n      case 'zoomout':\n        //        this._createZoominOrZoomoutLink();\n        break;\n      case 'legend':\n        //this._createLegendLink();\n        break;\n      case 'stylesheet':\n        this._createStylesheetLink();\n        break;\n      case 'alternate':\n        this._createAlternateLink(); // add media attribute\n        break;\n      case 'license':\n        // this._createLicenseLink();\n        break;\n    }\n    // create the type of templated leaflet layer appropriate to the rel value\n    // image/map/features = templated(Image/Feature), tile=templatedTile,\n    // this._tempatedTileLayer = M.templatedTile(pane: this.extentElement._leafletLayer._container)\n    // add to viewer._map dependant on map-extent.checked, layer-.checked\n    // what else?\n  }\n  disconnectedCallback() {\n    switch (this.rel.toLowerCase()) {\n      case 'stylesheet':\n        if (this._stylesheetHost) {\n          this.link.remove();\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  _createAlternateLink(mapml) {\n    if (this.href && this.projection) this._alternate = true;\n  }\n  _createStylesheetLink() {\n    // if the parent element is a map-link, the stylesheet is a link that should\n    //  be loaded as part of a templated layer processing i.e. on moveend\n    //  and the generated <link> that implements this <map-link> should be located\n    //  in the parent <map-link>._templatedLayer.container root node if\n    //  the _templatedLayer is an instance of M.TemplatedTileLayer or M.TemplatedFeaturesLayer\n    //\n    // if the parent node (or the host of the shadow root parent node) is layer-, the link should be created in the _layer\n    // container\n    this._stylesheetHost =\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().host\n        : this.parentElement;\n    if (this._stylesheetHost === undefined) return;\n\n    this.link = document.createElement('link');\n    this.link.mapLink = this;\n    this.link.setAttribute('href', new URL(this.href, this.getBase()).href);\n    copyAttributes(this, this.link);\n\n    if (this._stylesheetHost._layer) {\n      this._stylesheetHost._layer.appendStyleLink(this);\n    } else if (this._stylesheetHost._templatedLayer) {\n      this._stylesheetHost._templatedLayer.appendStyleLink(this);\n    } else if (this._stylesheetHost._extentLayer) {\n      this._stylesheetHost._extentLayer.appendStyleLink(this);\n    }\n\n    function copyAttributes(source, target) {\n      return Array.from(source.attributes).forEach((attribute) => {\n        if (attribute.nodeName !== 'href')\n          target.setAttribute(attribute.nodeName, attribute.nodeValue);\n      });\n    }\n  }\n\n  async _createTemplatedLink() {\n    // conditions check\n    // the tms and type attributes are optional, may need to be checked in future\n    this.parentExtent =\n      this.parentNode.nodeName.toUpperCase() === 'MAP-EXTENT'\n        ? this.parentNode\n        : this.parentNode.host;\n    if (!this.tref || !this.parentExtent) return;\n    try {\n      await this.parentExtent.whenReady();\n      await this._templateVars.inputsReady;\n    } catch (error) {\n      console.log('Error while creating templated link: ' + error);\n      return;\n    }\n    this.mapEl = this.getMapEl();\n    // create the layer type appropriate to the rel value\n    this.zIndex = Array.from(\n      this.parentExtent.querySelectorAll(\n        'map-link[rel=image],map-link[rel=tile],map-link[rel=features]'\n      )\n    ).indexOf(this);\n    if (\n      (this.rel === 'tile' && this.type === 'application/pmtiles') ||\n      this.type === 'application/vnd.mapbox-vector-tile'\n    ) {\n      let options = {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      };\n      this._templatedLayer = M.templatedPMTilesLayer(\n        this._templateVars,\n        options\n      ).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'tile') {\n      this._templatedLayer = M.templatedTileLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        crs: M[this.parentExtent.units],\n        errorTileUrl:\n          'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==',\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'image') {\n      this._templatedLayer = M.templatedImageLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'features') {\n      // map-feature retrieved by link will be stored in shadowRoot owned by link\n      this.attachShadow({ mode: 'open' });\n      this._templatedLayer = M.templatedFeaturesLayer(this._templateVars, {\n        zoomBounds: this.getZoomBounds(),\n        extentBounds: this.getBounds(),\n        zIndex: this.zIndex,\n        pane: this.parentExtent._extentLayer.getContainer(),\n        linkEl: this\n      }).addTo(this.parentExtent._extentLayer);\n    } else if (this.rel === 'query') {\n      this.attachShadow({ mode: 'open' });\n      L.extend(this._templateVars, this._setupQueryVars(this._templateVars));\n      L.extend(this._templateVars, { extentBounds: this.getBounds() });\n    }\n  }\n  _setupQueryVars(template) {\n    // process the inputs associated to template and create an object named\n    // query with member properties as follows:\n    // {width: 'widthvarname',\n    //  height: 'heightvarname',\n    //  left: 'leftvarname',\n    //  right: 'rightvarname',\n    //  top: 'topvarname',\n    //  bottom: 'bottomvarname'\n    //  i: 'ivarname'\n    //  j: 'jvarname'}\n    //  x: 'xvarname' x being the tcrs x axis\n    //  y: 'yvarname' y being the tcrs y axis\n    //  z: 'zvarname' zoom\n    //  title: link title\n\n    var queryVarNames = { query: {} },\n      inputs = template.values;\n\n    for (var i = 0; i < template.values.length; i++) {\n      var type = inputs[i].getAttribute('type'),\n        units = inputs[i].getAttribute('units'),\n        axis = inputs[i].getAttribute('axis'),\n        name = inputs[i].getAttribute('name'),\n        position = inputs[i].getAttribute('position'),\n        rel = inputs[i].getAttribute('rel'),\n        select = inputs[i].tagName.toLowerCase() === 'map-select';\n      if (type === 'width') {\n        queryVarNames.query.width = name;\n      } else if (type === 'height') {\n        queryVarNames.query.height = name;\n      } else if (type === 'location') {\n        switch (axis) {\n          case 'x':\n          case 'y':\n          case 'column':\n          case 'row':\n            queryVarNames.query[axis] = name;\n            break;\n          case 'longitude':\n          case 'easting':\n            if (position) {\n              if (position.match(/.*?-left/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelleft = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileleft = name;\n                } else {\n                  queryVarNames.query.mapleft = name;\n                }\n              } else if (position.match(/.*?-right/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelright = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tileright = name;\n                } else {\n                  queryVarNames.query.mapright = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'latitude':\n          case 'northing':\n            if (position) {\n              if (position.match(/top-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixeltop = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tiletop = name;\n                } else {\n                  queryVarNames.query.maptop = name;\n                }\n              } else if (position.match(/bottom-.*?/i)) {\n                if (rel === 'pixel') {\n                  queryVarNames.query.pixelbottom = name;\n                } else if (rel === 'tile') {\n                  queryVarNames.query.tilebottom = name;\n                } else {\n                  queryVarNames.query.mapbottom = name;\n                }\n              }\n            } else {\n              queryVarNames.query[axis] = name;\n            }\n            break;\n          case 'i':\n            if (units === 'tile') {\n              queryVarNames.query.tilei = name;\n            } else {\n              queryVarNames.query.mapi = name;\n            }\n            break;\n          case 'j':\n            if (units === 'tile') {\n              queryVarNames.query.tilej = name;\n            } else {\n              queryVarNames.query.mapj = name;\n            }\n            break;\n          default:\n          // unsuportted axis value\n        }\n      } else if (type === 'zoom') {\n        //<input name=\"...\" type=\"zoom\" value=\"0\" min=\"0\" max=\"17\">\n        queryVarNames.query.zoom = name;\n      } else if (select) {\n        /*jshint -W104 */\n        const parsedselect = inputs[i].htmlselect;\n        queryVarNames.query[name] = function () {\n          return parsedselect.value;\n        };\n      } else {\n        /*jshint -W104 */\n        const input = inputs[i];\n        queryVarNames.query[name] = function () {\n          return input.getAttribute('value');\n        };\n      }\n    }\n    return queryVarNames;\n  }\n  _initTemplateVars() {\n    // set up the URL template and associated inputs (which yield variable values when processed)\n    var varNamesRe = new RegExp('(?:{)(.*?)(?:})', 'g'),\n      zoomInput = this.parentElement.querySelector('map-input[type=\"zoom\" i]'),\n      includesZoom = false,\n      linkedZoomInput;\n\n    var template = this.tref;\n    if (template === M.BLANK_TT_TREF) {\n      for (let i of this.parentElement.querySelectorAll('map-input')) {\n        template += `{${i.getAttribute('name')}}`;\n      }\n    }\n    this.zoomInput = zoomInput;\n\n    var v,\n      vcount = template.match(varNamesRe) || [],\n      inputs = [],\n      inputsReady = [];\n    while ((v = varNamesRe.exec(template)) !== null) {\n      let varName = v[1],\n        inp = this.parentElement.querySelector(\n          'map-input[name=' + varName + '],map-select[name=' + varName + ']'\n        );\n      if (inp) {\n        // this \"associates\" the input to this  map-link\n        inputs.push(inp);\n        inputsReady.push(inp.whenReady());\n\n        // I think this means that regardless of whether the tref includes\n        // a reference to the zoom input, it gets associated to the link\n        // and used (to specify the native zoom bounds??) for the templated(Tile|Image|Features)Layer\n        if (\n          inp.hasAttribute('type') &&\n          inp.getAttribute('type').toLowerCase() === 'zoom'\n        ) {\n          linkedZoomInput = inp;\n          includesZoom = true;\n        }\n        // moved a block to map-select to transcribe the map-select into an\n        // actual html select for inclusion in the layer control.\n\n        // TODO: if this is an input@type=location\n        // get the TCRS min,max attribute values at the identified zoom level\n        // save this information as properties of the mapExtent,\n        // perhaps as a bounds object so that it can be easily used\n        // later by the layer control to determine when to enable\n        // disable the layer for drawing.\n      } else {\n        console.log(\n          'input with name=' +\n            varName +\n            ' not found for template variable of same name'\n        );\n      }\n    }\n    if (template && vcount.length === inputs.length) {\n      if (!includesZoom && zoomInput) {\n        inputs.push(zoomInput);\n        linkedZoomInput = zoomInput;\n      }\n      let step = zoomInput ? zoomInput.getAttribute('step') : 1;\n      if (!step || step === '0' || isNaN(step)) step = 1;\n      // template has a matching input for every variable reference {varref}\n      this._templateVars = {\n        template: decodeURI(new URL(template, this.getBase())),\n        linkEl: this,\n        rel: this.rel,\n        type: this.type,\n        values: inputs,\n        inputsReady: Promise.allSettled(inputsReady),\n        zoom: linkedZoomInput,\n        projection: this.parentElement.units,\n        tms: this.tms,\n        step: step\n      };\n    }\n  }\n  getZoomBounds() {\n    return this._getZoomBounds(this._templateVars.zoom);\n  }\n  /**\n   * TODO: review getBounds for sanity, also getFallbackBounds, perhaps integrate\n   * there is no other kind of bounds but native....\n   *  each rectangle must be established and valid and converted to PCRS coordinates...\n    // \"native\" bounds = input type=location min max || map-extent/map-meta name=extent min,max || layer-/map-meta name=extent min,max || layer projection min/max\n */\n  getBounds() {\n    let template = this._templateVars;\n    let inputs = template.values,\n      projection = this.parentElement.units,\n      boundsUnit = {};\n    boundsUnit.name = M.FALLBACK_CS;\n    let bounds = M[projection].options.crs.tilematrix.bounds(0),\n      locInputs = false,\n      numberOfAxes = 0,\n      horizontalAxis = false,\n      verticalAxis = false;\n    for (let i = 0; i < inputs.length; i++) {\n      if (inputs[i].getAttribute('type') === 'location') {\n        if (!inputs[i].getAttribute('max') || !inputs[i].getAttribute('min'))\n          continue;\n        let max = +inputs[i].getAttribute('max'),\n          min = +inputs[i].getAttribute('min');\n        switch (inputs[i].getAttribute('axis').toLowerCase()) {\n          case 'x':\n          case 'longitude':\n          case 'column':\n          case 'easting':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.x = min;\n            bounds.max.x = max;\n            boundsUnit.horizontalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          case 'y':\n          case 'latitude':\n          case 'row':\n          case 'northing':\n            boundsUnit.name = M.axisToCS(\n              inputs[i].getAttribute('axis').toLowerCase()\n            );\n            bounds.min.y = min;\n            bounds.max.y = max;\n            boundsUnit.verticalAxis = inputs[i]\n              .getAttribute('axis')\n              .toLowerCase();\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    if (\n      boundsUnit.horizontalAxis &&\n      boundsUnit.verticalAxis &&\n      ((boundsUnit.horizontalAxis === 'x' && boundsUnit.verticalAxis === 'y') ||\n        (boundsUnit.horizontalAxis === 'longitude' &&\n          boundsUnit.verticalAxis === 'latitude') ||\n        (boundsUnit.horizontalAxis === 'column' &&\n          boundsUnit.verticalAxis === 'row') ||\n        (boundsUnit.horizontalAxis === 'easting' &&\n          boundsUnit.verticalAxis === 'northing'))\n    ) {\n      locInputs = true;\n    }\n    if (locInputs) {\n      let zoomValue = this._templateVars.zoom?.hasAttribute('value')\n        ? +this._templateVars.zoom.getAttribute('value')\n        : 0;\n      bounds = M.boundsToPCRSBounds(\n        bounds,\n        zoomValue,\n        projection,\n        boundsUnit.name\n      );\n    } else if (!locInputs) {\n      bounds = this.getFallbackBounds(projection);\n    }\n    return bounds;\n  }\n  getFallbackBounds(projection) {\n    let bounds;\n\n    let zoom = 0;\n    let metaExtent = this.parentElement.getMeta('extent');\n    if (metaExtent) {\n      let content = M._metaContentToObject(metaExtent.getAttribute('content')),\n        cs;\n\n      zoom = content.zoom || zoom;\n\n      let metaKeys = Object.keys(content);\n      for (let i = 0; i < metaKeys.length; i++) {\n        if (!metaKeys[i].includes('zoom')) {\n          cs = M.axisToCS(metaKeys[i].split('-')[2]);\n          break;\n        }\n      }\n      let axes = M.csToAxes(cs);\n      bounds = M.boundsToPCRSBounds(\n        L.bounds(\n          L.point(\n            +content[`top-left-${axes[0]}`],\n            +content[`top-left-${axes[1]}`]\n          ),\n          L.point(\n            +content[`bottom-right-${axes[0]}`],\n            +content[`bottom-right-${axes[1]}`]\n          )\n        ),\n        zoom,\n        projection,\n        cs\n      );\n    } else {\n      let crs = M[projection];\n      bounds = crs.options.crs.pcrs.bounds;\n    }\n    return bounds;\n  }\n  getBase() {\n    let layer = this.getRootNode().host;\n    //\n    let relativeURL =\n      this.getRootNode().querySelector('map-base') &&\n      this.getRootNode() instanceof ShadowRoot\n        ? this.getRootNode().querySelector('map-base').getAttribute('href')\n        : /* local content? */ !(this.getRootNode() instanceof ShadowRoot)\n        ? /* use the baseURI algorithm which takes into account any <base> */\n          this.getRootNode().querySelector('map-base')?.getAttribute('href') ||\n          this.baseURI\n        : /* else use the resolved <layer- src=\"...\"> value */ new URL(\n            layer.src,\n            layer.baseURI\n          ).href;\n\n    // when remote content, use layer.src as base else use baseURI of map-link\n    let baseURL =\n      this.getRootNode() instanceof ShadowRoot\n        ? new URL(layer.src, layer.baseURI).href\n        : this.baseURI;\n    return new URL(relativeURL, baseURL).href;\n  }\n  /**\n   * Return BOTH min/max(Display)Zoom AND min/maxNativeZoom which\n   * are options that can be passed to L.GridLayer...\n   * https://leafletjs.com/reference.html#gridlayer-minzoom\n   *\n   * @param {Object} zoomInput - is an element reference to a map-input[type=zoom]\n   * @returns {Object} - returns {minZoom: n,maxZoom: n,minNativeZoom: n,maxNativeZoom: n}\n   */\n  _getZoomBounds(zoomInput) {\n    // native variables should ONLY come from map-input min/max attributes\n    // BUT they should fall back to map-meta or projection values for min/max (display) zoom\n    // display zoom variables should be EQUAL to native unless specified differently\n    // via map-meta name=zoom\n    // in particular minNativeZoom being > minZoom can be problematic because\n    // you fetch tiles at larger scales (i.e. many many small tiles) and render\n    // them at smaller scale (i.e. little postage stamps), which can freez your\n    // browser and bury a tile cache in requests, getting you banned/blocked\n    //\n    // minZoom = map-meta name=zoom min || input type=zoom min || projection minZoom\n    // minNativeZoom = input type=zoom min || minZoom\n    // maxZoom = map-meta name=zoom max || input type=zoom max || projection maxZoom\n    // maxNativeZoom = input type=zoom max || maxZoom\n\n    let zoomBounds = {};\n    // search document from here up, using closest source of zoom bounds info\n    let meta = this.parentElement.getMeta('zoom');\n    let metaMin = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.min\n      : null;\n    zoomBounds.minZoom =\n      metaMin || (zoomInput ? +zoomInput.getAttribute('min') : 0);\n    zoomBounds.minNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('min')\n      : zoomBounds.minZoom;\n    let metaMax = meta\n      ? +M._metaContentToObject(meta.getAttribute('content'))?.max\n      : null;\n    zoomBounds.maxZoom =\n      metaMax ||\n      (zoomInput\n        ? +zoomInput.getAttribute('max')\n        : M[this.parentElement.units].options.resolutions.length - 1);\n    zoomBounds.maxNativeZoom = zoomInput\n      ? +zoomInput.getAttribute('max')\n      : zoomBounds.maxZoom;\n\n    return zoomBounds;\n  }\n  _validateDisabled() {\n    let isVisible = false,\n      map = this.getMapEl(),\n      mapZoom = map.zoom,\n      extent = map.extent,\n      xmin = extent.topLeft.pcrs.horizontal,\n      xmax = extent.bottomRight.pcrs.horizontal,\n      ymin = extent.bottomRight.pcrs.vertical,\n      ymax = extent.topLeft.pcrs.vertical,\n      mapBounds = L.bounds(L.point(xmin, ymin), L.point(xmax, ymax));\n\n    if (this._templatedLayer) {\n      isVisible = this._templatedLayer.isVisible();\n    } else if (this.rel === 'query') {\n      const minZoom = this.extent.zoom.minZoom,\n        maxZoom = this.extent.zoom.maxZoom,\n        withinZoomBounds = (z) => {\n          return minZoom <= z && z <= maxZoom;\n        };\n\n      if (this.getBounds().overlaps(mapBounds) && withinZoomBounds(mapZoom)) {\n        isVisible = true;\n      }\n    }\n    return isVisible;\n  }\n  _createSelfOrStyleLink() {\n    let layerEl = this.getLayerEl();\n    const changeStyle = function (e) {\n      L.DomEvent.stop(e);\n      layerEl.dispatchEvent(\n        new CustomEvent('changestyle', {\n          detail: {\n            src: e.target.getAttribute('data-href'),\n            preference: this.media['prefers-map-content']\n          }\n        })\n      );\n    };\n\n    let styleOption = document.createElement('div'),\n      styleOptionInput = styleOption.appendChild(\n        document.createElement('input')\n      );\n    styleOptionInput.setAttribute('type', 'radio');\n    styleOptionInput.setAttribute('id', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionInput.setAttribute(\n      'name',\n      // grouping radio buttons based on parent layer's style <detail>\n      'styles-' + L.stamp(styleOption)\n    );\n    styleOptionInput.setAttribute('value', this.getAttribute('title'));\n    styleOptionInput.setAttribute(\n      'data-href',\n      new URL(this.href, this.getBase()).href\n    );\n    var styleOptionLabel = styleOption.appendChild(\n      document.createElement('label')\n    );\n    styleOptionLabel.setAttribute('for', 'rad-' + L.stamp(styleOptionInput));\n    styleOptionLabel.innerText = this.title;\n    if (this.rel === 'style self' || this.rel === 'self style') {\n      styleOptionInput.checked = true;\n    }\n    this._styleOption = styleOption;\n    styleOptionInput.addEventListener('click', changeStyle.bind(this));\n  }\n  getLayerControlOption() {\n    return this._styleOption;\n  }\n\n  // Resolve the templated URL with info from the sibling map-input's\n  resolve() {\n    if (this.tref) {\n      let obj = {};\n      const inputs = this.parentElement.querySelectorAll('map-input');\n      if (this.rel === 'image') {\n        // image/map\n        for (let i = 0; i < inputs.length; i++) {\n          const inp = inputs[i];\n          obj[inp.name] = inp.value;\n        }\n        console.log(obj); // DEBUGGING\n        return L.Util.template(this.tref, obj);\n      } else if (this.rel === 'tile') {\n        // TODO. Need to get tile coords from moveend\n        // should be done/called from the TemplatedTilelayer.js file\n        return obj;\n      } else if (this.rel === 'query') {\n        // TODO. Need to get the click coords from click event\n        // should be done/called from the templatedlayer.js file\n      } else if (this.rel === 'features') {\n        // TODO.\n      }\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer, ready;\n      switch (this.rel.toLowerCase()) {\n        // for some cases, require a dependency check\n        case 'tile':\n        case 'image':\n        case 'features':\n          ready = '_templatedLayer';\n          break;\n        case 'style':\n        case 'self':\n        case 'style self':\n        case 'self style':\n          ready = '_styleOption';\n          break;\n        case 'query':\n          ready = 'shadowRoot';\n          break;\n        case 'alternate':\n          ready = '_alternate';\n          break;\n        case 'zoomin':\n        case 'zoomout':\n        case 'legend':\n        case 'stylesheet':\n        case 'license':\n          resolve();\n          break;\n        default:\n          resolve();\n          break;\n      }\n      if (this[ready]) {\n        resolve();\n      }\n      interval = setInterval(testForLinkReady, 300, this);\n      failureTimer = setTimeout(linkNotDefined, 10000);\n      function testForLinkReady(linkElement) {\n        if (linkElement[ready]) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!linkElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-link was disconnected while waiting to be ready');\n        }\n      }\n      function linkNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for link to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapLink","HTMLElement","observedAttributes","#hasConnected","type","this","getAttribute","val","startsWith","setAttribute","rel","includes","href","hasAttribute","URL","getBase","resolve","hreflang","tref","M","BLANK_TT_TREF","media","_metaContentToObject","tms","projection","extent","_templateVars","Object","assign","_convertAndFormatPCRS","getBounds","parentExtent","units","zoom","getZoomBounds","zoomTo","let","map","getMapEl","_map","xmin","topLeft","pcrs","horizontal","xmax","bottomRight","ymin","vertical","ymax","bounds","L","point","center","options","crs","unproject","getCenter","maxZoom","minZoom","setView","getMaxZoom","animate","getClosest","getLayerEl","attributeChangedCallback","name","oldValue","newValue","_initTemplateVars","constructor","super","connectedCallback","toLowerCase","_createTemplatedLink","_createSelfOrStyleLink","_createStylesheetLink","_createAlternateLink","disconnectedCallback","_stylesheetHost","link","remove","mapml","_alternate","source","target","getRootNode","ShadowRoot","host","parentElement","undefined","document","createElement","mapLink","Array","from","attributes","forEach","attribute","nodeName","nodeValue","_layer","appendStyleLink","_templatedLayer","_extentLayer","parentNode","toUpperCase","whenReady","inputsReady","error","console","log","mapEl","zIndex","querySelectorAll","indexOf","zoomBounds","extentBounds","pane","getContainer","linkEl","templatedPMTilesLayer","addTo","templatedTileLayer","errorTileUrl","templatedImageLayer","attachShadow","mode","templatedFeaturesLayer","extend","_setupQueryVars","template","queryVarNames","query","inputs","values","i","length","axis","position","select","tagName","width","height","match","pixelleft","tileleft","mapleft","pixelright","tileright","mapright","pixeltop","tiletop","maptop","pixelbottom","tilebottom","mapbottom","tilei","mapi","tilej","mapj","parsedselect","htmlselect","value","input","linkedZoomInput","varNamesRe","RegExp","zoomInput","querySelector","includesZoom","v","vcount","exec","varName","inp","push","step","isNaN","decodeURI","Promise","allSettled","_getZoomBounds","zoomValue","boundsUnit","FALLBACK_CS","tilematrix","locInputs","max","min","axisToCS","x","horizontalAxis","y","verticalAxis","boundsToPCRSBounds","getFallbackBounds","metaExtent","getMeta","content","cs","metaKeys","keys","split","axes","csToAxes","layer","relativeURL","src","baseURI","baseURL","meta","metaMin","minNativeZoom","metaMax","resolutions","maxNativeZoom","_validateDisabled","isVisible","mapZoom","mapBounds","overlaps","z","layerEl","styleOption","styleOptionInput","appendChild","stamp","styleOptionLabel","innerText","title","checked","_styleOption","addEventListener","e","DomEvent","stop","dispatchEvent","CustomEvent","detail","preference","bind","getLayerControlOption","obj","Util","reject","interval","failureTimer","ready","setInterval","linkElement","clearInterval","clearTimeout","isConnected","setTimeout"],"mappings":"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"}